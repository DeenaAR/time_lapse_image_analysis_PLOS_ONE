%% D18: written mostly by Matt Whitfield and modified by Deena Rennerfeldt
%% Clear important variables

clear Parents RealN Data numcell genN twin1 twin2 touching touchnum...
    genlist genname parentgrid labelgrid areagrid xlocgrid ylocgrid ...
    numcells neighbors orderstarters
%% Set things up
%specify the colony name (e.g., 'Laughing Shadow (T43C70)' and figure path
colony_name='Colony 2';
figurepath='C:\';


% "Flag" each variable (by setting it's value equal to 1 instaed of 0)
% corresponding to the analyses to be made (see comments for each
% variable).
savefigures=0;      % Flag if you want to save the figures to figurepath.

moviemade = 0;      % Flag to make a movie of original (or masked) images 
                    % overlayed with images of cells colored for 
                    % generation.  path1, path2, and savepath must be 
                    % specified.  These terms are searchable.

twinanalysis=1;     % Flag to do the "twin analysis" that categorizes twins
                    % based on whether or not they divided

dotouch=1;          % Flag if cell-cell contacts have been measured in 
                    % CellProfiler (via the MeasureObjectNeighbors module).
                    
grid=1;             % Number of grids being analyzed at a time (just one 
                    % for Project 4).

dopre=0;            % Flag if analyzing the previous presence of cells. 
                    % This requires the ConvertObjectsToImage module as
                    % well as saving the masked images as mat files.
                    
doplot=0;           % Flag to generate figures

docurr=0;           % Unsure what this does.  
                    % Matt's comment: 1 if detailed current contact runclosea

umperpx=.639;       % microns per pixel - determines cell area and depends 
                    % on the resolution of the images
                    
timepointfix=96;    % conversion factor from # of time points to days.  If 
                    % time points are 15 minutes apart, set this to 96 
                    % (i.e., there are 96 15-minute time points in a day)
                    
threshsml=8000;     % Spread area threshold for considering a cell small

lifetimecutoff=1.5;  % Lifetime of a cell to be considered senescent (for 
                    % twin analysis).

% mintimepoint=50;     % the minimum number of time points a cell has to exi
%                     % to be considered in the twin analyses

% Call function to extract data from input CellProfiler outputs
[parentgrid,labelgrid,areagrid,xlocgrid,ylocgrid,numcells,neighbors,...
    eccentricity,integrateddistance,formfactor]=getdata6(handles,dotouch,...
    grid);
% The outputs generated by this function (getdata)are arrays.  See getdata
% for information on how those data are arranged by CellProfiler.  The 
% array outputs are each described below:

% parentgrid:  A "parent object" is the object in the preceeding image that
%              overlaps with the current object (i.e. it's the object/cell 
%              in the previous time point).  A "parent object number" is
%              the label assigned to the parent object.  parentgrid is an
%              array of the parent object numbers for each object at each 
%              time point
%             
% labelgrid:   An array of label numbers for each object at each time point             
%
% areagrid:    An array of the area of each object (in px) at each time
%              point
% xlocgrid, ylocgrid:   x- and y-coordinates of the center of each object
%                       at each time point
% 
% numcells:    the number of cells at each time point
% 
% neighbors:   neighbors is an array constructed in getdata6.m.  The array
%              has two columns: t and n.  t measures percent touching; n
%              measures number of neighbors (for each object at each time 
%              time point).  It is set up to calculate these two variables
%              for a threshold distance of 5, 10, 15, and 20 pixels.  
%              Example: neighbors(3).n is an array containing the number of
%              neighbors each object has at each time point when a distance
%              of 15 pixels was considered for an object to be a neighbor.


timepts=length(parentgrid);         % # of time points
rtime=(1:timepts)./timepointfix;    % For graphing purposes


% If you want to calculate cells interaction with the previous presence of cells at each location
if dopre==1
    totalcontact(1:timepts)= struct('a',[]);
    totalpxls(1:timepts)=  struct('a',[]);
    path3='C:\';
    [totalcontact,totalpxls]=calcprevcontact(path3,2,RealN,totalcontact,totalpxls);
end

% Scale the inputs
for i=1:timepts
    areagrid{i}=double(areagrid{i});
    for j=1:length(areagrid{i})
        if areagrid{i}(j)~=-1
            areagrid{i}(j)=areagrid{i}(j)*umperpx^2;
            xlocgrid{i}(j)=xlocgrid{i}(j)*umperpx;
            ylocgrid{i}(j)=ylocgrid{i}(j)*umperpx;
            integrateddistance{i}(j)=integrateddistance{i}(j)*umperpx;
        end
    end
end

cells=length(parentgrid{1,1});      % total number of tracked cells (split cells and new cells)
if length(parentgrid{1,1})>1000
    cells2=sum(parentgrid{1,1}(1:1000)~=-1);
    cells1=sum(parentgrid{1,1}(1001:end)~=-1)+1000;
    startcells1=cells1;
else
    cells2=cells;
    cells1=0;
    startcells1=0;
end
startcells2=cells2;
startercells=labelgrid{1,1}(find(labelgrid{1,1}~=-1)); % # of cells at start of experiment 


% Initialize data storage structures
Parents(1:cells)= struct('ancestor',[],'parent',[],'leave',[],'split',[],'children',[],'twin',[],'lineage',[],'lineagetime',[],'born',[],'appear',[],'gen',1,'lifetime',0,'descend',-1,'splitsize',0);
for o=1:length(labelgrid{1,1})
    Parents(o).ancestor=labelgrid{1,1}(o);        % parent # of cells at start
end
Data(1:cells)= struct('num',[],'label',[],'gen',[],'time',[],'area',[],'small',0,'xloc',[],'yloc',[],'prec',[],'pren',[],'eccentricity',[],'formfactor',[],'migrate',[],'totaldist',[]);

RealN(1:timepts)=struct('num',[],'label',[],'parent',0,'gen',0,'area',0,'xloc',[],'yloc',[],'prec',[],'pren',[],'eccentricity',[],'formfactor',[],'totaldist',[],'distcentroid',[]);
RealN(1).num=(1:cells)*0;
RealN(1).label=(1:cells)*0;
RealN(1).parent=(1:cells)*0;
RealN(1).gen=(1:cells)*0;
RealN(1).area=(1:cells)*0;
RealN(1).xloc=(1:cells)*0;
RealN(1).yloc=(1:cells)*0;
RealN(1).eccentricity=(1:cells)*0;
RealN(1).formfactor=(1:cells)*0;
RealN(1).totaldist=(1:cells)*0;
RealN(1).distcentroid=(1:cells)*0;
if dopre==1
    RealN(1).prec=(1:cells)*0;
    RealN(1).pren=(1:cells)*0;
end
if dotouch==1
    for np=3
        RealN(1).touch(np).t=(1:cells)*0;
        RealN(1).touch(np).n=(1:cells)*0;
    end
end

%% Convert the raw input data into synthesized metrics
for t=1:timepts % total number of timesteps
    for c=1:length(parentgrid{1,t})         % number of cells at that timestep
        if parentgrid{1,t}(c)~=-1
            cellN=labelgrid{1,t}(c);        % Cell number (split cells keep parent #)
            parentN=parentgrid{1,t}(c);     % # of cell in previous timestep 
            cellA=areagrid{1,t}(c);         % Cell area
            xloc=xlocgrid{1,t}(c);          % X position of center of mass
            yloc=ylocgrid{1,t}(c);          % Y position of center of mass
            eccen=eccentricity{1,t}(c);
            formfact=formfactor{1,t}(c);
            totaldist=integrateddistance{1,t}(c);
            if c<1000
                cells=cells2;
            else
                cells=cells1;
            end

            if dotouch==1
                for np=1:4
                    touching(np).a=neighbors(np).t{1,t}(c);
                    touchingnum(np).a=neighbors(np).n{1,t}(c);
                end
            end
            cellI=c;
            indexC=find(labelgrid{1,t}==cellN);      % twin cells
            indexP=find(parentgrid{1,t}==parentN);   % if two then split this time

            % uniqueN - unique number assigned to daughter cells when cells split
            if t~=1
                uniqueN=RealN(t-1).num(find(RealN(t-1).label==cellN & RealN(t-1).parent==parentN));
                gen=RealN(t-1).gen(find(RealN(t-1).label==cellN & RealN(t-1).parent==parentN));
            else
                uniqueN=cellN;
                gen=1;
            end

            if length(indexP)>1 && t~=1 && (parentN~=0) % if split this timestep
                cells=cells+1;
                Parents(uniqueN).split=t;               % time that cell split
                Parents(uniqueN).children=horzcat(Parents(uniqueN).children,cells);     % Unique id# of child cells 
                Parents(cells).parent=uniqueN;     % Unique id# of child cells 
                if cellN<=startcells2 || (cellN>1000 && cellN<=startcells1)
                    Parents(cellN).lineage=horzcat(Parents(cellN).lineage,cells);       % Unique id# of all cells that parent cell at start of experiment gives rise to
                    Parents(cellN).lineagetime=horzcat(Parents(cellN).lineagetime,t);       % Time of splits
                end
                uniqueN=cells;                          % Assigns unique number to child cell
                Parents(uniqueN).born=t;                % time daughter cell is "born"
                gen=gen+1; 
                Parents(uniqueN).gen=gen;               % generation of daughter cell
                Parents(uniqueN).ancestor=cellN;          % original parent #
            elseif (parentN==0) && t~=1                   % when a new cell appears (not from division)
                cells=cells+1;
                uniqueN=cells;
                gen=1;
                Parents(uniqueN).gen=gen;               % generation of daughter cell
                %Parents(uniqueN).ancestor=cellN;          % original parent #
                Parents(uniqueN).appear=t;
            end
            if dopre==1
                prec=totalcontact(1,t).a(uniqueN);      % total number of previous cell contact under cell
                pren=totalpxls(1,t).a(uniqueN);         % number of pixels under cell
            end
            RealN(t).num(uniqueN)=uniqueN;
            RealN(t).label(uniqueN)=cellN;
            RealN(t).parent(uniqueN)=cellI;  
            RealN(t).gen(uniqueN)=gen; 
            RealN(t).area(uniqueN)=cellA;
            RealN(t).xloc(uniqueN)=xloc;
            RealN(t).yloc(uniqueN)=yloc;
            RealN(t).eccentricity(uniqueN)=eccen;
            RealN(t).formfactor(uniqueN)=formfact;
            RealN(t).totaldist(uniqueN)=totaldist;
            if dopre==1
                RealN(t).prec(uniqueN)=prec;
                RealN(t).pren(uniqueN)=pren;
            end
            if dotouch==1
                for np=1:4
                    RealN(t).touch(np).t(uniqueN)=touching(np).a;
                    RealN(t).touch(np).n(uniqueN)=touchingnum(np).a;
                end
            end
            if c<1000
                cells2=cells;
            else
                cells1=cells;
            end
        end
    end
end
%%%%% Find the centroid of a colony at each time point

centroid = zeros(timepts,2);
for i = 1:timepts
    %cell coordinates:
    XValues=(handles.Measurements.RelabeledCells.Location_Center_X{1,i})*umperpx;
    YValues=(handles.Measurements.RelabeledCells.Location_Center_Y{1,i})*umperpx;
    
    if length(XValues) == 1 %if there is only one cell
        XCoord = XValues;
        YCoord = YValues;
    else
        XCoord=mean(XValues);
        YCoord=mean(YValues);
    end
    centroid(i,1) = XCoord; 
    centroid(i,2) = YCoord;
end
%%%%% Put the distance from centroid for each cell into RealN:

for i = 1:timepts %for each time point
    for j = 1:length(RealN(i).num) %for each cell at a time point
        if RealN(i).num(j)~=0
        RealN(i).distcentroid(j) = sqrt((RealN(i).xloc(j) - centroid(i,1))^2 + (RealN(i).yloc(j) - centroid(i,2))^2);
        else
        RealN(i).distcentroid(j)=0;
        end
    end 
end

% Determine lineage of cells that split after start of experiment
for c=startcells2+1:cells
    if c<=cells2 || c>startcells1
        child1=c;
        child2=c;
        i=1;
        while isempty(Parents(child1).children)==0
            child2=Parents(child1).children(2);
            child1=Parents(child1).children(1);
            Parents(c).lineage=horzcat(Parents(c).lineage,child1,child2);
    %         Parents(c).lineagetime=horzcat(Parents(c).lineagetime,t,t);
            while isempty(Parents(child2).children)==0
                child1=Parents(child2).children(1);
                child2=Parents(child2).children(2);
                Parents(c).lineage=horzcat(Parents(c).lineage,child1,child2);
            end
        end
    end
end

% Determine twins from cells existing in first image
for i=1:startcells2
    for ii=1:2:length(Parents(i).lineage)
        Parents(Parents(i).lineage(ii)).twin=Parents(i).lineage(ii+1);
        Parents(Parents(i).lineage(ii+1)).twin=Parents(i).lineage(ii);
    end
end

% Determine twins from cells existing in first image
if c>1000
    for i=1001:startcells1
        for ii=1:2:length(Parents(i).lineage)
            Parents(Parents(i).lineage(ii)).twin=Parents(i).lineage(ii+1);
            Parents(Parents(i).lineage(ii+1)).twin=Parents(i).lineage(ii);
        end
    end
end

for i=1:cells
    if c<=cells2 || c>startcells1
        % These only produce output for cells that have split and been born
        Parents(i).lifetime=Parents(i).split-Parents(i).born;
        if isempty(Parents(i).lifetime)==1
            Parents(i).lifetime=0;
        end
        Parents(i).descend=length(Parents(i).lineage);

        % Find out avg cell size 8-4 timepoints before split
        if Parents(i).split>0
            if isempty(Parents(i).appear)==0
                if (Parents(i).split-Parents(i).appear)>8
                    Parents(i).splitsize=mean([RealN(Parents(i).split-4).area(i),RealN(Parents(i).split-5).area(i),RealN(Parents(i).split-6).area(i),RealN(Parents(i).split-7).area(i),RealN(Parents(i).split-8).area(i)]);
                end
            else
                if (Parents(i).split-Parents(i).born)>8
                    Parents(i).splitsize=mean([RealN(Parents(i).split-4).area(i),RealN(Parents(i).split-5).area(i),RealN(Parents(i).split-6).area(i),RealN(Parents(i).split-7).area(i),RealN(Parents(i).split-8).area(i)]);
                end
            end
        end
        if isempty(Parents(i).splitsize)==1
            Parents(i).splitsize=0;
        end

        % To convert data to matrix form for plotting
        counter=0;
        for j=1:timepts
            if i<=RealN(j).num(end)
                if RealN(j).num(i)~=0
                    counter=counter+1;
                    Data(i).num=RealN(j).num(i);
                    Data(i).label=RealN(j).label(i);
                    Data(i).gen=RealN(j).gen(i);
                    Data(i).time(counter)=j;
                    Data(i).area(counter)=RealN(j).area(i);
                    Data(i).xloc(counter)=RealN(j).xloc(i);
                    Data(i).yloc(counter)=RealN(j).yloc(i);
                    Data(i).eccentricity(counter)=RealN(j).eccentricity(i);
                    Data(i).formfactor(counter)=RealN(j).formfactor(i);
                    Data(i).totaldist(counter)=RealN(j).totaldist(i);
                    Data(i).distcentroid(counter)=RealN(j).distcentroid(i);
                    if counter>1
                        Data(i).migrate(counter)=sqrt((Data(i).xloc(counter)-Data(i).xloc(counter-1))^2+(Data(i).yloc(counter)-Data(i).yloc(counter-1))^2)*2;
                    else
                        Data(i).migrate(counter)=0;
                    end
                    if dopre==1
                        Data(i).prec(counter)=RealN(j).prec(i);
                        Data(i).pren(counter)=RealN(j).pren(i);
                    end
                    if dotouch==1
                        for np=1:4
                            Data(i).touch(np).t(counter)=RealN(j).touch(np).t(i);
                            Data(i).touch(np).n(counter)=RealN(j).touch(np).n(i);
                        end
                    end
                end
            end
        end
    end
    Data(i).totaldist= Data(i).totaldist-Data(i).totaldist(1);
end

% find cells that disappear but dont divide
for i=1:length(RealN(timepts).num)
    if isempty(Data(i).time)==0
        if isempty(Parents(i).split)==1 && Data(i).time(end)~=timepts
            Parents(i).leave=Data(i).time(end)+1;
        end
    end
end

numcell=(1:timepts)*0;
areacell=(1:timepts)*0;
areacellsem=(1:timepts)*0;
smallcell=zeros(length(threshsml),timepts);
largecell=zeros(length(threshsml),timepts);
for o=1:timepts
    numcell(o)=numcells(o);         % total # of cells over time
    areacell(o)=mean(RealN(o).area(RealN(o).area~=0));
    areacellsem(o)=std(RealN(o).area(RealN(o).area~=0))/sqrt(length(RealN(o).area(RealN(o).area~=0)));
    for p=1:length(threshsml)
        smallcell(p,o)=sum(areagrid{o}<=threshsml(p) & areagrid{o}>0);
        largecell(p,o)=sum(areagrid{o}>threshsml(p));
    end
end


genlist=[];
lifetime=[];
dividesize=[];
% descend=[];
descend(1:cells)=(1:cells)*0-1;
genname=[];
for i=1:cells
    if Parents(i).lifetime>0 && (Parents(i).ancestor<=startcells2 )%|| (Parents(i).ancestor<=startcells1 &&  Parents(i).ancestor>1000))
        lifetime=vertcat(lifetime,Parents(i).lifetime);
        dividesize=vertcat(dividesize,Parents(i).splitsize);
        genlist=vertcat(genlist,Parents(i).gen);
        genname=vertcat(genname,Data(i).num);
%         descend=vertcat(descend,Parents(i).descend);
    end
    descend(i)=Parents(i).descend;
end

% Statistics within each generation of cells
genN(1:timepts)=struct('A',[],'N',[],'Std',[],'CSb',[],'CSl',[]);
for o=1:max(genlist)+1
    CSb=0;
    CSl=0;
    for i=1:timepts
        genN(o).A(i)=mean(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        genN(o).N(i)=length(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        genN(o).Std(i)=std(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        for j=1:length(Parents)
            if Parents(j).born==i 
                if Parents(j).gen==o & (Parents(j).ancestor<=startcells2 | (Parents(j).ancestor<=startcells1 &  Parents(j).ancestor>1000))
                    CSb=CSb+1;
                end
            end
            if Parents(j).leave==i 
                if Parents(j).gen==o & ((Parents(j).ancestor<=startcells2 & Parents(j).ancestor>0) | (Parents(j).ancestor<=startcells1 &  Parents(j).ancestor>1000))
                   CSl=CSl+1;
                end
            end
        end 
        genN(o).CSb(i)=CSb;
        genN(o).CSl(i)=CSl;
    end
end

% Cumulative sum
cumm(1:max(genlist))=struct('a',[],'b',[],'c',[],'d',[]);
for j=2:max(genlist)+1
    for i=1:length(Parents)
        if Parents(i).gen==j && (Parents(i).ancestor<=startcells2 || (Parents(i).ancestor<=startcells1 &&  Parents(i).ancestor>1000))
            cumm(j-1).a=horzcat(cumm(j-1).a,Parents(i).born);
            if isempty(Parents(i).leave)~=1
                cumm(j-1).c=horzcat(cumm(j-1).c,Parents(i).leave);
            end
        end
    end
    cumm(j-1).a=sort(cumm(j-1).a);
    cumm(j-1).b=horzcat(0,1:length(cumm(j-1).a),length(cumm(j-1).a));
    cumm(j-1).a=horzcat(0,cumm(j-1).a,timepts)/timepointfix;
    
    cumm(j-1).c=sort(cumm(j-1).c);
    cumm(j-1).d=horzcat(0,1:length(cumm(j-1).c),length(cumm(j-1).c));
    cumm(j-1).c=horzcat(0,cumm(j-1).c,timepts)/timepointfix;
end

%%% TWIN INFO
firsttwin=1;
count=1;
for i=startcells2+1:cells
    if isempty(Parents(i).twin)==0 && firsttwin~=Parents(i).twin
        twin1.N(count)=i;                           % Cell number
        twin1.P(count)=Parents(i).descend;          % Number of progeny    
        twin1.MA(count)=mean(Data(i).area);         % Cell area
        twin1.LT(count)=Parents(i).lifetime/timepointfix;     % Cell lifetime (only has a value if cell divides)                      % 
        if twin1.LT(count)>0
            twin1.TTD(count)=twin1.LT(count);       % time to depart (TTD)
        elseif isempty(Parents(i).leave)==0         % Cell leaves
            twin1.TTD(count)=(Parents(i).leave-Parents(i).born)/timepointfix;
        else
            twin1.TTD(count)=(timepts-Parents(i).born)/timepointfix;
        end

        twin1.G(count)=Parents(i).gen;
        if dotouch==1
            for np=1:4
                twin1.C(np).t(count)=mean(Data(i).touch(np).t);
                twin1.C(np).n(count)=mean(Data(i).touch(np).n);
            end
        end
        twin2.N(count)=Parents(i).twin;
        twin2.P(count)=Parents(Parents(i).twin).descend;
        twin2.MA(count)=mean(Data(Parents(i).twin).area);
        twin2.LT(count)=Parents(Parents(i).twin).lifetime/timepointfix;
        if twin2.LT(count)>0
            twin2.TTD(count)=twin2.LT(count);
        elseif isempty(Parents(Parents(i).twin).leave)==0
            twin2.TTD(count)=(Parents(Parents(i).twin).leave-Parents(Parents(i).twin).born)/timepointfix;
        else
            twin2.TTD(count)=(timepts-Parents(Parents(i).twin).born)/timepointfix;
        end

        twin2.G(count)=Parents(Parents(i).twin).gen;  
        if dotouch==1
            for np=1:4
                twin2.C(np).t(count)=mean(Data(Parents(i).twin).touch(np).t);
                twin2.C(np).n(count)=mean(Data(Parents(i).twin).touch(np).n);
            end
        end
        firsttwin=i;

          % Change order so that twin 1 always is one with most contacts
            if twin2.LT(count)>=twin1.LT(count)
%                 if twin2.C(count)*twin2.LT(count)>=twin1.C(count)*twin1.LT(count)
                store(1)=twin1.N(count);
                store(2)=twin1.P(count);           
                store(3)=twin1.MA(count);
                store(4)=twin1.LT(count);
                store(5)=twin1.TTD(count);
                store(6)=twin1.G(count);
                if dotouch==1
                    for np=1:4
                        store(2*np+5)=twin1.C(np).t(count);
                        store(2*np+6)=twin1.C(np).n(count);
                    end
                end
                twin1.N(count)=twin2.N(count);
                twin1.P(count)=twin2.P(count);           
                twin1.MA(count)=twin2.MA(count);
                twin1.LT(count)=twin2.LT(count);
                twin1.TTD(count)=twin2.TTD(count);
                twin1.G(count)=twin2.G(count); 
                if dotouch==1
                    for np=1:4
                        twin1.C(np).t(count)=twin2.C(np).t(count); 
                        twin1.C(np).n(count)=twin2.C(np).n(count);
                    end
                end
                twin2.N(count)=store(1);
                twin2.P(count)=store(2);           
                twin2.MA(count)=store(3);
                twin2.LT(count)=store(4);
                twin2.TTD(count)=store(5);
                twin2.G(count)=store(6);
                if dotouch==1
                    for np=1:4
                        twin2.C(np).t(count)=store(2*np+5);
                        twin2.C(np).n(count)=store(2*np+6);
                    end
                end
            end
            count=count+1;
    end    
end

% Group twin cells
EqualDiv=[]; EqualNoDiv=[]; UnEqualDiv1=[]; UnEqualDiv2=[]; EqualDivp=[]; EqualNoDivp=[]; UnEqualDivp=[]; EqualDivpp=[]; EqualNoDivpp=[]; UnEqualDivpp=[];
for i=1:length(twin1.LT)
    if twin1.TTD(i)>=lifetimecutoff && twin2.TTD(i)>=lifetimecutoff                                             % Cells that both do not divide within lifetimecutoff days
        EqualNoDiv=horzcat(EqualNoDiv,[twin1.N(i) twin2.N(i)]);
        EqualNoDivp=horzcat(EqualNoDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            EqualNoDivpp=horzcat(EqualNoDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    elseif twin1.TTD(i)<lifetimecutoff && twin2.TTD(i)<lifetimecutoff && twin1.LT(i)>0 && twin2.LT(i)>0       % Cells that both do divide within lifetimecutoff days
        EqualDiv=horzcat(EqualDiv,[twin1.N(i) twin2.N(i)]);
        EqualDivp=horzcat(EqualDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            EqualDivpp=horzcat(EqualDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    elseif (twin1.TTD(i)>=lifetimecutoff && twin2.TTD(i)<lifetimecutoff) && twin2.LT(i)>0                      % One cell divides within lifetimecutoff days, one does not
        UnEqualDiv1=horzcat(UnEqualDiv1,twin1.N(i));                                % Slow dividing cell
        UnEqualDiv2=horzcat(UnEqualDiv2,twin2.N(i));                                % Fast dividing cell
        UnEqualDivp=horzcat(UnEqualDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            UnEqualDivpp=horzcat(UnEqualDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    elseif (twin1.TTD(i)<lifetimecutoff && twin2.TTD(i)>=lifetimecutoff) && twin1.LT(i)>0                      % The other cell divides within two days, one does not
        UnEqualDiv1=horzcat(UnEqualDiv1,twin2.N(i));
        UnEqualDiv2=horzcat(UnEqualDiv2,twin1.N(i));
        UnEqualDivp=horzcat(UnEqualDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            UnEqualDivpp=horzcat(UnEqualDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    end
end
EqualDiv=sort(EqualDiv);
EqualNoDiv=sort(EqualNoDiv);
UnEqualDiv1=sort(UnEqualDiv1);
UnEqualDiv2=sort(UnEqualDiv2);



    
    
    
    
% %  **Matt's version of calculating center (center = where first division took place):
% % colonycenter(1:length(startercells))=struct('x',[],'y',[]);
% % for i=1:length(startercells)
% %     if isempty(Parents(i).children)==0
% %         colonycenter(i).x=Data(i).xloc(end);
% %         colonycenter(i).y=Data(i).yloc(end);
% %     else
% %         colonycenter(i).x=Data(i).xloc(1);
% %         colonycenter(i).y=Data(i).yloc(1);
% %     end
% %     for j=1:size(Data,2)
% %         if Data(j).label==i
% %             for k=1:length(Data(j).xloc)
% %                 Data(j).distcenter(k)=sqrt((Data(j).xloc(k)-colonycenter(i).x)^2+(Data(j).yloc(k)-colonycenter(i).y)^2);
% %             end
% %         end
% %     end
% % end

%% Plot things
if doplot==1
    % Set up the color scheme for the plots
    splitC={[1 0.396 0.435],[0.996 0.584 0.360],[1 0.898 0.415],[0.627 0.862 0.384],[0.286 0.803 0.956],[0.188 0.435 0.819],[0.631 0.607 0.858]};
    splitC2={[1 0.396 0.435],[0.996 0.584 0.360],[1 0.898 0.415],[0.627 0.862 0.384],[0.286 0.803 0.956],[0.188 0.435 0.819],[0.631 0.607 0.858]}; % color code    % Plot area over time for cells
    generationlist={'1st','2nd','3rd','4th','5th','6th','7th','8th','9th','10th','11th','12th','13th','14th','15th','16th','17th','18th','19th','20th'};
    

%%%%% Average area of each generation over time 
        offset=zeros(1,max(genlist)+1); % Use offset if want to normalize to when each generation starts. This needs to be set by hand.
        legendentry=[];
        fig_area_vs_time_avg= figure('Color', [1 1 1]);
        hold on
        for o=1:max(genlist)+1
            plot(rtime(1:end)-offset(o),genN(o).A,'Color',splitC{o},'LineWidth',1)
            legendentry{o}=generationlist{o};
        end
            set(gca,'FontSize',16, 'linewidth', 2); 
            title(colony_name)
            ax=gca;
            ax.XTick= [1:4];
            ylabel('Spread cell area (um^2)','FontWeight','bold','FontSize',16)
            xlabel('Time (days)','FontWeight','bold','FontSize',16)
            legend(legendentry,'Location','northwest')
            cd(figurepath)
            if savefigures==1
            print(fig_area_vs_time_avg,['area-vs-time-avg_' char(colony_name)],'-dpng');
            end

        
        %%% If plotting overall average cell area
%          hold on
%          sareacell=smooth(areacell)';
%          patch([rtime fliplr(rtime)],[sareacell+areacellsem fliplr(sareacell-areacellsem)],[0.7 0.7 0.7],'EdgeColor','none');
%          plot(rtime,sareacell,'Color','k','LineWidth',1)
%          legendentry{o+1}='Overall';
%        
%          xlabel('Time (days)')
%          ylabel('Area (um^2)')
%          axis([0 rtime(end) 0 max(areacell)*2])
%          legend(legendentry)
%          title(colony_name)
  
%%%%% Plot cell area over time for all cells. A circle is plotted for a 
%%%%% cell division and an x is plotted when a cell disappears
        fig_area_vs_time=figure('Color', [1 1 1]); 
        hold on
        for k=1:length(startercells)
            parcell=startercells(k);
%           figure, hold on if want new figure for each starting cell
            for i=1:cells
                
                if Data(i).label==parcell
                   plot(((Data(i).time(2:end)-1)-1)./timepointfix,Data(i).area(2:end),'Color',splitC{Data(i).gen})
                    if isempty(Parents(i).leave)==0
                        plot(((Parents(i).leave-2)-1)./timepointfix,Data(i).area(end),'x')
                    end
                    if isempty(Parents(i).split)==0
                        plot(((Parents(i).split-2)-1)./timepointfix,Data(i).area(end),'o','Color',splitC{Data(i).gen})
                    end    
                end
            end
        end
        set(gca,'FontSize',16, 'linewidth', 2); 
        title(colony_name)
        ax=gca;
        ax.XTick= [1:4];
        ylabel('Spread cell area (um^2)','FontWeight','bold','FontSize',16)
        xlabel('Time (days)','FontWeight','bold','FontSize',16)
         if savefigures==1
            print(fig_area_vs_time,['area-vs-time_' char(colony_name)],'-dpng')
         end
        % legend(legendentry,'Location','best')
        % ****still need to figure out how to make a legend on this one... 
      

       
%%%%% Number in each generation over time
% Use offset if want to normalize to when each generation starts. This 
% needs to be set by hand.
%       offset2=[0,0,.8,1.8,3,4,5];
        
        offset2=zeros(1,max(genlist)+1); 
        legendentry=[];
        fig_cells_per_generation=figure;
        hold on
        for o=max(genlist)+1:-1:1
            plot(rtime(1:end)-offset2(o),genN(o).N,'Color',splitC{o},'LineWidth',1)
            legendentry{o}=generationlist{o};
        end
        legend(fliplr(legendentry), 'location', 'northwest')
        set(gca,'FontSize',16, 'linewidth', 2); 
        title(colony_name)
        ax=gca;
        ax.XTick= [1:4];
        ylabel('Number of Cells','FontWeight','bold','FontSize',16)
        xlabel('Time (Days)','FontWeight','bold','FontSize',16)
         if savefigures==1
            print(fig_cells_per_generation,['cells-per-generation_' char(colony_name)],'-dpng');
         end

%%%%% Number or fraction of cells in each generation that have divided over time
%         legendentry=[];
%         figure, hold on
%         for o=1:max(genlist)+1
%             plot(rtime(1:end)-offset2(o),genN(o).CSb,'Color',splitC{o})
%             legendentry{o}=generationlist{o};
%         end
%         title('# cells in each generation')
%         xlabel('Time (days)')
%         ylabel('# cells')
%         legend(legendentry)   


%%%%% Percent in each generation over time
%         legendentry=[];
%         figure, hold on
%         for o=max(genlist)+1:-1:1
%             plot(rtime(1:end)-offset2(o),genN(o).N./numcell,'Color',splitC{o},'LineWidth',2)
%             legendentry{o}=generationlist{o};
%         end
%         title('% cells in each generation')
%         xlabel('Time (days)')
%         ylabel('Fraction cells')
%         legend(fliplr(legendentry))

%%%%% # Descendants vs. Divide Size 

        fig_descendants_vs_divide_size = figure;
        hold on
%       hdescend=descend(startercells);
%       hist(hdescend,34)
        remdescend=zeros(1,length(startercells));
        for i=1:length(startercells)
            remD=0;
            remI=[];
            for j=1:length(Parents(startercells(i)).lineage)  
                if Data(Parents(startercells(i)).lineage(j)).time(end)==timepts
                    remD=remD+1;
                    remI(remD)=j;
                end
            end
            %remdescend is the number of cells each starting cell produced:
            remdescend(i)=length(remI);  
        end
            %find the divide size of each starting cell
        eachstartcell=RealN(1).num;
        startcelldividesize=zeros(1, length(eachstartcell));
            for i = 1:length(RealN(1).num) %for each starting cell
                for j = 1:length(RealN) %for each time point
                    %if the starting cell divided in the j-1 time point:
                    if RealN(j).num(i)==0      
                    %then the divide size of that cell is the area 4 time 
                    %points before it divided:
                    if j>5
                    startcelldividesize(i)=RealN(j-5).area(i);
                    else
                    startcelldividesize(i)=RealN(1).area(i);
                    end
                    if remdescend(i)==0
                    startcelldividesize(i)=RealN(1).area(i);
                    end
                    %move on to the next starting cell:
                    break
                    end                
                end
            end
%%%   Starting cell(s) number of descendants vs divide size
% Put data in table to copy to meta excel sheet:
%         aa_size_vs_desendants_table = [startcelldividesize' remdescend'];
% Make a plot of size_vs_descendants
%         plot(startcelldividesize,remdescend,'*k')
%         title(colony_name)
%         set(gca,'FontSize',16, 'linewidth', 2); 
%         ylabel('Number of Descendants','FontWeight','bold','FontSize',16)
%         xlabel('Divide Size (um^2)','FontWeight','bold','FontSize',16)
%         axis([0 max(startcelldividesize)+1000 0 max(remdescend+1)])
%         ax=gca;
%         ax.XTick= [0:1000:max(startcelldividesize)+1000];
%         ylabel('Number of Cells','FontWeight','bold','FontSize',16)
%         xlabel('Time (Days)','FontWeight','bold','FontSize',16)
%         if savefigures==1
%             print(fig_descendants_vs_divide_size,['descendents_vs_divide_size_' char(colony_name)],'-dpng');
%         end
               
%%% Cells ordered by number of progeny           
%    figure, hold on  
%         hist(remdescend)
%         title('Histogram of # Decendents')
%         xlabel('# decendants')
%         figure
%         cumdesc=fliplr(cumsum(sort(remdescend)));
%         plot(cumdesc./cumdesc(1),'k')
%         xlabel('Cells ordered by # of progeny')
%         ylabel('Fraction of Progeny')

    
%%%%% Comparison of starting cell size vs whether or not it divides
%     figure, hold on
%     x=(1:2:30)*410*umperpx^2;
%     hist(RealN(1).area(startercells),x)
%     h= findobj(gca,'Type','patch');
%     set(h,'FaceColor','r')
%     hist(RealN(1).area((descend(1:length(RealN(1).label))==0) & RealN(1).label~=0),x)
%     xlim([0 28000])
%     title('Cell Starting Size')
%     xlabel('Cell Starting Size (um^2)')
%     ylabel('Count')
%     legend('Divide','Never divide')

%%%%% Comparison of ending cell size vs Divisions at select timepts
% *** doesn't seem to work correctly - end up with pink caps on all the bars? 
%         howoften=ceil(timepts/16);
%         figure, hold on
%         count=1;
%         for tp=1:howoften:timepts
%     %       figure, hold on
%             legendentry=[];
%             subplot(4,4,count)
%     %         x=(1:2:30)*1750;
%             x=(1:1:45)*1000;
% 
%             n=[];
%             for o=1:max(genlist)+1
%                 n(o,:)=hist(RealN(tp).area(RealN(tp).area>0 & (RealN(tp).label<=startcells2 | (RealN(tp).label>1000 & RealN(tp).label<=startcells1))  & RealN(tp).gen==o),x);
%     %             RealN(tp).area(RealN(tp).area>0 & (RealN(tp).label<=startcells2 | (RealN(tp).label>1000 & RealN(tp).label<=startcells1))  & RealN(tp).gen==o);
%     %             plot([genN(o).A(tp) genN(o).A(tp)],[0 120],'Color',splitC{o})
%                 legendentry{o}=generationlist{o};
%             end
%             cmap = colormap;
%             cmap2=cmap;
%             cmap2(1,:)=splitC{1};
%             if max(genlist)+1>2
%                 for i=2:max(genlist)
%                     for j=(i-2)*round(97/(max(genlist)))+2:(i-1)*round(97/(max(genlist)))+1
%                         cmap2(j,:)=splitC{i};
%                     end
%                 end
%             end
%             cmap2(97,:)=splitC{max(genlist)+1}; %????
%             colormap(cmap2)
%             bar(x,n','stacked')
%     %         plot([threshsml threshsml],[0 120],'Color',[.6 .6 .6])
%     %         ylim([0 125])
%             title(tp/timepointfix)
%             xlabel('Spread cell area (um^2)')
%             ylabel('Count')
%             
%     %         saveas(gcf,num2str(tp),'bmp')
%     %         close
%             count=count+1;
%         end
%         legend(legendentry)
        
 
%%%% Only run this section if a division has occurred
    if isempty(lifetime)==0

    %%%%% Boxplot of division size per generation    

       fig_divide_size_vs_generation=figure('Color', [1 1 1]);
       boxplot(vertcat(dividesize,dividesize),vertcat(genlist,zeros(length(genlist),1)+1),'plotstyle','compact','colors','krbgmcy','jitter',0)
       %%for the beehive plot (can't get it to work yet):  
%      plotSpread(vertcat(lifetime,lifetime)/timepointfix,'distributionIdx',vertcat(zeros(length(genlist),1)+5,genlist-1),'distributionColors',{[.6 .6 .6]},'xyOri','flipped')
%      ylim([0 18000])
        forxaxis(1)={'Overall'};
        for i=2:max(genlist)
            forxaxis(i)={num2str(i)};
        end
        set(gca,'xtick',1:max(genlist),'xticklabel',forxaxis,'FontSize',16, 'linewidth', 2); 
        title(colony_name)
        xlabel('Generation','FontWeight','bold','FontSize',16)
          
        xlabh = get(gca,'XLabel'); % for x axis label offset
        set(xlabh,'Position',get(xlabh,'Position') - [0 5 0]);% for x axis label offset
        ylabel('Divide Size (um^2)','FontWeight','bold','FontSize',16)
        if savefigures==1
            set(gcf,'PaperPositionMode','auto')
            print(fig_divide_size_vs_generation,['divide-size-vs-generation_' char(colony_name)],'-dpng', '-r0');
        end
       
          
    %%%%% Boxplot of doubling time for each generation
        fig_generation_vs_lifetime=figure('Color', [1 1 1]);
        boxplot(vertcat(lifetime,lifetime)/timepointfix,vertcat(genlist,zeros(length(genlist),1)+1),'plotstyle','compact','orientation','horizontal','colors','krbgmcy','jitter',0,'medianstyle','target');
        xlim([0 4])
        set(gca,'ytick',1:max(genlist),'yticklabel',forxaxis, 'FontSize',16, 'linewidth', 2); 
        title(colony_name)
        ylabel('Generation','FontWeight','bold','FontSize',16)
        xlabel('Lifetime (days)','FontWeight','bold','FontSize',16)
        xlim([0 2])
        if savefigures==1
            set(gcf,'PaperPositionMode','auto')
            print(fig_generation_vs_lifetime,['generation_vs_lifetime_' char(colony_name)],'-dpng', '-r0');
        end
       


    %%%%% Histogram of doubling time for each generation
%     ***Needs titles on subfigures, plus bars are different sizes and not
%     all generations show up
%         figure
%         
%         for o=2:max(genlist)
%             subplot(max(genlist)-1,1,o-1)
%             hold on
%             hist(lifetime(genlist==o)./timepointfix)
%             xlim([0 4])
%         end
%         title('Histogram of cell lifetimes for each generation')
%         xlabel('Lifetime (days)')
%        % Check for significant differences
%         for i=2:max(genlist)-1
%             [h,pd(i-1),ci,stats] = ttest2(dividesize((genlist==i)),dividesize((genlist==i+1)),.05,'both','unequal');
%             [h,pl(i-1),ci,stats] = ttest2(lifetime((genlist==i)),lifetime((genlist==i+1)),.05,'both','unequal');
%         end   

    %%%%% Plot division size vs lifetime
        fig_division_size_vs_lifetime=figure('Color', [1 1 1]);
        hold on
        for i=1:length(lifetime)
            plot(lifetime(i)/timepointfix,dividesize(i),'o','MarkerEdgeColor','k','MarkerFaceColor',splitC{genlist(i)})
        end
        set(gca,'ytick',0:1000:max(dividesize)+1000,'xtick',0:1:4,'FontSize',16, 'linewidth', 2)
        xlim([0 4])
        ylim([0 max(dividesize)+1000])
        xlabel('Lifetime (days)','FontWeight','bold','FontSize',16)
        ylabel('Divide Size (um^2)','FontWeight','bold','FontSize',16)
        title(colony_name)
         if savefigures==1
            set(gcf,'PaperPositionMode','auto');
            print(fig_division_size_vs_lifetime,['division_size_vs_lifetime_' char(colony_name)],'-dpng', '-r0');
        end
    end  
           
   %%%%% Distance from center vs cell size at end
       fig_location_vs_cell_size=figure('Color', [1 1 1]);
       hold on
        for i=1:size(Data,2)
            if sum(Data(i).time==timepts)~=0
                plot(Data(i).area(end),Data(i).distcentroid(end),'o','MarkerEdgeColor','k','MarkerFaceColor',splitC{Data(i).gen});
            end
        end
        set(gca,'FontSize',16, 'linewidth', 2,'YTick',0:100:(max(RealN(timepts).distcentroid)+100),'XTick',0:2000:max(RealN(timepts).area)+2000); 
        title(colony_name);
        xlabel('Cell area (um^2)','FontWeight','bold','FontSize',16);
        ylabel('Distace from center (um)','FontWeight','bold','FontSize',16);     
        if savefigures==1
            set(gcf,'PaperPositionMode','auto');
            print(fig_location_vs_cell_size,['location_vs_cell_size_' char(colony_name)],'-dpng', '-r0');
        end
    
    %%%%% Cumulative distance centroid has travelled 
    centroid_distance=zeros(timepts);
    centroid_time=zeros(timepts);
    
    for each_centroid = 1:timepts
    centroid_distance(each_centroid) = sqrt(abs((centroid(1,1)-centroid(each_centroid,1)))^2 + abs((centroid(1,2)-centroid(each_centroid,2)))^2);
    centroid_time(each_centroid)= each_centroid/timepointfix;
    end
    distance_um=centroid_distance.*umperpx;
    fig_centroid_travel=figure('Color', [1 1 1]);
    hold on
    plot(centroid_time,distance_um,'Marker','o','LineStyle','none');
    set(gca,'FontSize',16, 'linewidth', 2)
    ylabel({'Centroid Distance from'; 'Initial Position (um)'},'FontWeight','bold','FontSize',16)
    xlabel('Time (Days)','FontWeight','bold','FontSize',16)
    title(colony_name)
     if savefigures==1
            set(gcf,'PaperPositionMode','auto');
            print(fig_centroid_travel,['centroid_distance_travelled_' char(colony_name)],'-dpng', '-r0');
     end
    %%%%% Total # and fraction of large vs small cells over time
        fig_large_vs_small=figure;
        subplot(2,1,1)
        hold on
        plot(rtime,numcell,'k');
        plot(rtime,smallcell,':','Color',[.6 .6 .6]);
        plot(rtime,largecell,'Color',[.5 .5 .5]);
        set(gca,'FontSize',16, 'linewidth', 2);
        title(colony_name,'FontWeight','bold','FontSize',16);
        l=legend('Total','Small','Large');
        l.Location='northwest';
        l.FontSize=10;
        ylabel('# cells','FontWeight','bold','FontSize',16);
        
        subplot(2,1,2)
        hold on
        for p=1:length(threshsml)
            plot(rtime,smallcell(p,:)./numcell,':','Color',[.6 .6 .6]);
            plot(rtime,largecell(p,:)./numcell,'Color',[.5 .5 .5]);
        end
        set(gca,'FontSize',16, 'linewidth', 2);
        xlabel('Time (days)','FontWeight','bold','FontSize',16);
        ylabel('Fraction','FontWeight','bold','FontSize',16);

       if savefigures==1
                set(gcf,'PaperPositionMode','auto')
                print(fig_large_vs_small,['fig_large_vs_small_' char(colony_name)],'-dpng', '-r0');
       end
    
    
%     %%%%% Plot causes where there were unequal twin divisions if any
%     if isempty(UnEqualDiv1)==0
%         figure, hold on
%     %     for i=1:length(twin1.P)
%     %         plot((twin1.MA(i)-twin2.MA(i)),(twin1.TTD(i)-twin2.TTD(i)),'o','MarkerFaceColor',splitC2{twin1.G(i)})
%     %     end
%         for i=1:length(UnEqualDiv1)
%             Ln=UnEqualDiv1(i);
%             Sn=UnEqualDiv2(i);
%             plot((twin1.MA(twin1.N==Ln | twin1.N==Sn)-twin2.MA(twin2.N==Ln | twin2.N==Sn)),(twin1.TTD(twin1.N==Ln | twin1.N==Sn)-twin2.TTD(twin2.N==Ln | twin2.N==Sn)),'o','MarkerFaceColor',splitC2{twin1.G(twin2.N==Ln | twin2.N==Sn)})
%         end
% 
%         title('Twin analysis')
%         xlabel('Difference in mean area')
%         ylabel('Difference in cell duration')
%     end

    %%%%% Order starting cells by the number of descendents 
        orderedstarters=[];
        for i=1:length(startercells) 
            orderedstarters(i)=(Parents(startercells(i)).descend);
        end
        [orderedstarters,b]=sort(orderedstarters,'descend');
        Ostarters=startercells(b);

%%%%% Plot the lineage trees
        % j=1 - no slope
        % j=2 - slope related to total distance cell traveled
        % j=3 - slope related to cell formfactor
        % j=4 - slope related to cell eccentricity
        % j=5 - slope related to distance to center of colony
        figtitle={'No Slope','Total Distance Traveled','Form Factor','Eccentricity','Distance from Center'};
        for j=1:5
              place=0;
%             dontplace=[137,138,139,140,151,152,153,154,165,166,167,168,180, 181, 182]; % If want to exclude any cells
            for k=1:length(startercells)
                parcell=startercells(k);
                figure('Color', [1 1 1],'name',[char(figtitle{j}) '_Starting Cell ' num2str(k)])
                set(gca,'FontSize',16, 'linewidth', 2,'YTick', []);
                title(colony_name,'FontWeight','bold','FontSize',16);
                xlabel('Time (days)','FontWeight','bold','FontSize',16);
                if (isempty(Parents(parcell).split)==0 & ((isempty(Parents(Parents(parcell).children(1)).leave) | (Parents(Parents(parcell).children(1)).leave>144)~=0) | (isempty(Parents(Parents(parcell).children(2)).leave) | (Parents(Parents(parcell).children(2)).leave>144)~=0))) | length(Data(parcell).time)>=144
                    place=place+1;
                    % If all to plotted on the same plot; can't get to work
                    % yet. From Matt's code:
%                     figure(2)
%                     subplot(floor(k/15)+1,rem((k+14),15)+1)
%                     while sum(place==dontplace)==1
%                         place=place+1;
%                     end
%                     h=subplot(11,15,place);
%                     set(h,'XTick',[],'YTick',[]);
                    hold on
                    children=horzcat(parcell,Parents(parcell).lineage);
                    locations=1:length(children);
                    Cl(1)=1;
                    marker=1;
                    for jj=2:length(children)
                        Cl(jj)=Cl(children==Parents(children(jj)).parent)+Data(children(jj)).gen/Data(children(jj)).gen^3.4*marker;
                        marker=marker*-1;
                    end
                    for i=1:length(children)
                           lineslope(1).a=0;
                           lineslope(2).a=Data(children(i)).totaldist./30000;
                           lineslope(3).a=(1-Data(children(i)).formfactor)./30;
                           lineslope(4).a=Data(children(i)).eccentricity./30;
                           lineslope(5).a=Data(children(i)).distcentroid./30000;
                           
                           plot(Data(children(i)).time/timepointfix,zeros(1,length(Data(children(i)).time))+Cl(i),'Color',[.4 .4 .4],'LineWidth',1) 
      
%                          area(Data(children(i)).time/timepointfix,Data(children(i)).area./5e5+Cl(i),'FaceColor',splitC2{Data(children(i)).gen},'BaseValue',Cl(i))
%                          area(Data(children(i)).time/timepointfix,-Data(children(i)).area./5e5+Cl(i),'FaceColor',splitC2{Data(children(i)).gen},'BaseValue',Cl(i))
                           patch([Data(children(i)).time/timepointfix fliplr(Data(children(i)).time/timepointfix)],[Data(children(i)).area./5e5+Cl(i)+lineslope(j).a fliplr(-Data(children(i)).area./5e5+Cl(i)+lineslope(j).a)],splitC2{Data(children(i)).gen},'EdgeColor','k');

%                          area(Data(children(i)).time/timepointfix,-Data(children(i)).touchnum./1e2+Cl(i),'FaceColor',splitC2{Data(children(i)).gen},'BaseValue',Cl(i))
%                          area(Data(children(i)).time/timepointfix,-Data(children(i)).touch./8e3+Cl(i),'FaceColor',splitC2{Data(children(i)).gen},'BaseValue',Cl(i))

                           plot(Data(children(i)).time/timepointfix,zeros(1,length(Data(children(i)).time))+Cl(i)+lineslope(j).a,'Color',splitC{Data(children(i)).gen},'LineWidth',1) 
                           if Parents(children(i)).descend>0
                            plot([Data(children(i)).time(end)/timepointfix Data(children(i)).time(end)/timepointfix],[Cl(i)+(Data(children(i)).gen+1)/(Data(children(i)).gen+1)^3.4 Cl(i)-(Data(children(i)).gen+1)/(Data(children(i)).gen+1)^3.4],'k','LineWidth',3)
                           end
%                       if isempty(Parents(children(i)).leave)==0
%                             plot((Parents(children(i)).leave-1)/timepointfix,Cl(i),'x','MarkerSize',10)
%                       end
                    end
                    axis([0 4 .65 1.35])
%                   view(90,90) %rotates trees 90 degrees
                    
                    %%% label the figures to indicate what the slopes mean:
                    if j==2
                    ylabel({'slope indicates'; 'total distance traveled'},'FontWeight','bold','FontSize',16);
                    elseif j==3
                    ylabel('slope indicates form factor','FontWeight','bold','FontSize',16);
                    elseif j==4
                    ylabel('slope indicates eccentricity','FontWeight','bold','FontSize',16);
                    elseif j==5
                    ylabel({'slope indicates distance'; 'from colony center'},'FontWeight','bold','FontSize',16);
                    else
                    end
                    
                    %%%save the figures:
                    if savefigures==1
                       if j == 1
                       set(gcf,'PaperPositionMode','auto')
                       print(gcf,['tree_no_slope_' num2str(k) '_' char(colony_name)],'-dpng', '-r0');
                       elseif j == 2
                       set(gcf,'PaperPositionMode','auto')
                       print(gcf,['tree_distance_travelled_' num2str(k) '_' char(colony_name)],'-dpng', '-r0');
                       elseif j == 3
                       set(gcf,'PaperPositionMode','auto')
                       print(gcf,['tree_form_factor_' num2str(k) '_' char(colony_name)],'-dpng', '-r0');
                       elseif j == 4
                       set(gcf,'PaperPositionMode','auto')
                       print(gcf,['tree_eccentricity_' num2str(k) '_' char(colony_name)],'-dpng', '-r0');
                       elseif j == 5
                       set(gcf,'PaperPositionMode','auto')
                       print(gcf,['tree_colony_center_' num2str(k) '_' char(colony_name)],'-dpng', '-r0');
                       else
                    end
                end
            end   
        end
        
%%%%% Make a color overlay movie of colony

    if moviemade==1
        warning('off','images:initSize:adjustingMag');
        path1='C:\Users\Deena\Desktop\temp_image_analysis\Colony_6_overall_2nd\Tracked\IDs';
        path2='I:\Trial_4-3\Data by Colony\Colony_6\Analysis\montages_for_movie\masked_montages\padded_images';
        savepath='I:\Trial_4-3\Data by Colony\Colony_6\Analysis\montages_for_movie\Overlay_3';
        
    	makemovie_v3(path1,path2,savepath,labelgrid,RealN) 
        moviemade=0; % (DR) this is probably not needed
    end
end

%% Twin analysis
%%%%%% This still needs tinkering; there aren't a lot of cells that fit
%%%%%% into the senescent or unequal divisions categories
% 1         % All cells after division from one of original cells that is around for at least 24 time points
% 2         % All cells after division from one of original cells that subsequently divide
% 3         % All cells after division from one of original cells that do not subsequently divide
% 4         % Twins that both divide within lifetimecutoff days
% 5         % Twins that both do not divide for at least lifetimecutoff days
% 6         % Twin that does divide within lifetimecutoff days when its twin doesn't
% 7         % Twin that doesn't divide for lifetimecutoff days when its twin does
% 8         % Parent of twins that both divide
% 9         % Parent of twins where one divides and one does not
% 10        % Parent of twins that both do not divide
% 11        % Parent of Parent of twins that both divide
% 12        % Parent of Parent of twins where one divides and one does not
% 13        % Parent of Parent of twins that both do not divide
if twinanalysis==1
colors={'y','b','r','g','r','y','b','g','b','k','g','b','k'};
clear savArea savT savPCells savMigrate
% How many cells fit into the above categories
typelengths=[cells-length(startercells) cells-length(startercells) cells-length(startercells) length(EqualDiv) length(EqualNoDiv) length(UnEqualDiv2) length(UnEqualDiv1) length(EqualDivp) length(UnEqualDivp) length(EqualNoDivp) length(EqualDivpp) length(UnEqualDivpp) length(EqualNoDivpp)]
for j=1:13
    savArea(j).a=zeros(typelengths(j),timepts-1);
    savMigrate(j).a=zeros(typelengths(j),timepts-1);
    for np=1:4
        savT(np).t(j).a=zeros(typelengths(j),timepts-1);
        savT(np).n(j).a=zeros(typelengths(j),timepts-1);
        savT(np).c(j).a=zeros(typelengths(j),timepts-1);
    end
    savPCells(j).a=zeros(typelengths(j),timepts-1);
    savPCells(j).c=zeros(typelengths(j),timepts-1);
end
count1=0;
count2=0;
count3=0;
timearound=1; % Threshold for cell lifetime to be analyzed (in timepoints; divide by timepointfix for days)
clip=1; % number of time points subtracted to account for cell balling up prior to division

for i=startcells2+1:cells           
    if i<1001 || i>startcells1              % Only look at cells that were not around in first frame
        if (Parents(i).ancestor<startcells2+1 & Parents(i).ancestor>0) |  (Parents(i).ancestor>1000 & Parents(i).ancestor<startcells1+1)        % Only look at cells that originated from one of the original cells
%             if (Parents(i).lifetime>24 & isempty(Parents(i).split)==0) | (Parents(i).lifetime>timearound | (Parents(i).leave-Parents(i).born)>timearound)
            if (isempty(Parents(i).leave)==0 & (Parents(i).leave-Parents(i).born)<timearound) | (isempty(Parents(i).split)==1 & (timepts-Parents(i).born)<timearound)   % Around for at least timearound/timepointfix days
            else % All cells that arose from original cells and have been around past threshold time (1)
                count1=count1+1; 
                savArea(1).a(count1,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).area(1:end-clip); % Area of these cells. Normalized to birth of cell at time 1.  
                savMigrate(1).a(count1,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).migrate(1:end-clip);
                if dotouch==1
                    for np=1:4
                        savT(np).t(1).a(count1,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).touch(np).t(1:end-clip);
                        savT(np).n(1).a(count1,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).touch(np).n(1:end-clip);
                        savT(np).c(1).a(count1,1:Data(i).time(end-clip)-Data(i).time(1)+1)=cumsum(Data(i).touch(np).n(1:end-clip));
                    end
                end
                if dopre==1
                    savPCells(1).a(count1,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).prec(1:end-clip);
                    savPCells(1).c(count1,1:Data(i).time(end-clip)-Data(i).time(1)+1)=cumsum(Data(i).prec(1:end-clip));
                end
                % Cells that arose from original cells and subsequently divide (2)
                if isempty(Parents(i).split)==0     
                    count2=count2+1;
                    savArea(2).a(count2,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).area(1:end-clip);
                    savMigrate(2).a(count2,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).migrate(1:end-clip);
                    if dotouch==1
                        for np=1:4
                            savT(np).t(2).a(count2,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).touch(np).t(1:end-clip);
                            savT(np).n(2).a(count2,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).touch(np).n(1:end-clip);
                            savT(np).c(2).a(count2,1:Data(i).time(end-clip)-Data(i).time(1)+1)=cumsum(Data(i).touch(np).n(1:end-clip));
                        end
                    end
                    if dopre==1
                        savPCells(2).a(count2,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).prec(1:end-clip);
                        savPCells(2).c(count2,1:Data(i).time(end-clip)-Data(i).time(1)+1)=cumsum(Data(i).prec(1:end-clip));
                    end
                % Cells that arose from original cells and do not subsequently divide (3)
                else                                
                    count3=count3+1;
                    savArea(3).a(count3,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).area(1:end-clip);
                    savMigrate(3).a(count3,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).migrate(1:end-clip);
                    if dotouch==1
                        for np=1:4
                            savT(np).t(3).a(count3,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).touch(np).t(1:end-clip);
                            savT(np).n(3).a(count3,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).touch(np).n(1:end-clip);
                            savT(np).c(3).a(count3,1:Data(i).time(end-clip)-Data(i).time(1)+1)=cumsum(Data(i).touch(np).n(1:end-clip));
                        end
                    end
                    if dopre==1
                        savPCells(3).a(count3,1:Data(i).time(end-clip)-Data(i).time(1)+1)=Data(i).prec(1:end-clip);
                        savPCells(3).c(count3,1:Data(i).time(end-clip)-Data(i).time(1)+1)=cumsum(Data(i).prec(1:end-clip));
                    end
                end
            end
        end
    end
end

% Twins that both divide
for i=1:length(EqualDiv)                
%     plot(Data(EqualDiv(i)).time-Data(EqualDiv(i)).time(1),Data(EqualDiv(i)).area);
    savArea(4).a(i,1:Data(EqualDiv(i)).time(end-clip)-Data(EqualDiv(i)).time(1)+1)=Data(EqualDiv(i)).area(1:end-clip);
    savMigrate(4).a(i,1:Data(EqualDiv(i)).time(end-clip)-Data(EqualDiv(i)).time(1)+1)=Data(EqualDiv(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).t(4).a(i,1:Data(EqualDiv(i)).time(end-clip)-Data(EqualDiv(i)).time(1)+1)=Data(EqualDiv(i)).touch(np).t(1:end-clip);
            savT(np).n(4).a(i,1:Data(EqualDiv(i)).time(end-clip)-Data(EqualDiv(i)).time(1)+1)=Data(EqualDiv(i)).touch(np).n(1:end-clip);
            savT(np).c(4).a(i,1:Data(EqualDiv(i)).time(end-clip)-Data(EqualDiv(i)).time(1)+1)=cumsum(Data(EqualDiv(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(4).a(i,1:Data(EqualDiv(i)).time(end-clip)-Data(EqualDiv(i)).time(1)+1)=Data(EqualDiv(i)).prec(1:end-clip);
        savPCells(4).c(i,1:Data(EqualDiv(i)).time(end-clip)-Data(EqualDiv(i)).time(1)+1)=cumsum(Data(EqualDiv(i)).prec(1:end-clip));
    end
end

% Parent of twins that both divide
for i=1:length(EqualDivp)                
%     plot(Data(EqualDiv(i)).time-Data(EqualDiv(i)).time(1),Data(EqualDiv(i)).area);
    savArea(8).a(i,1:Data(EqualDivp(i)).time(end-clip)-Data(EqualDivp(i)).time(1)+1)=Data(EqualDivp(i)).area(1:end-clip);
    savMigrate(8).a(i,1:Data(EqualDivp(i)).time(end-clip)-Data(EqualDivp(i)).time(1)+1)=Data(EqualDivp(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).t(8).a(i,1:Data(EqualDivp(i)).time(end-clip)-Data(EqualDivp(i)).time(1)+1)=Data(EqualDivp(i)).touch(np).t(1:end-clip);
            savT(np).n(8).a(i,1:Data(EqualDivp(i)).time(end-clip)-Data(EqualDivp(i)).time(1)+1)=Data(EqualDivp(i)).touch(np).n(1:end-clip);
            savT(np).c(8).a(i,1:Data(EqualDivp(i)).time(end-clip)-Data(EqualDivp(i)).time(1)+1)=cumsum(Data(EqualDivp(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(8).a(i,1:Data(EqualDivp(i)).time(end-clip)-Data(EqualDivp(i)).time(1)+1)=Data(EqualDivp(i)).prec(1:end-clip);
        savPCells(8).c(i,1:Data(EqualDivp(i)).time(end-clip)-Data(EqualDivp(i)).time(1)+1)=cumsum(Data(EqualDivp(i)).prec(1:end-clip));
    end
end

% Parent of Parent of twins that both divide
for i=1:length(EqualDivpp)  
%     plot(Data(EqualDiv(i)).time-Data(EqualDiv(i)).time(1),Data(EqualDiv(i)).area);
    savArea(11).a(i,1:Data(EqualDivpp(i)).time(end-clip)-Data(EqualDivpp(i)).time(1)+1)=Data(EqualDivpp(i)).area(1:end-clip);
    savMigrate(11).a(i,1:Data(EqualDivpp(i)).time(end-clip)-Data(EqualDivpp(i)).time(1)+1)=Data(EqualDivpp(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).t(11).a(i,1:Data(EqualDivpp(i)).time(end-clip)-Data(EqualDivpp(i)).time(1)+1)=Data(EqualDivpp(i)).touch(np).t(1:end-clip);
            savT(np).n(11).a(i,1:Data(EqualDivpp(i)).time(end-clip)-Data(EqualDivpp(i)).time(1)+1)=Data(EqualDivpp(i)).touch(np).n(1:end-clip);
            savT(np).c(11).a(i,1:Data(EqualDivpp(i)).time(end-clip)-Data(EqualDivpp(i)).time(1)+1)=cumsum(Data(EqualDivpp(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(11).a(i,1:Data(EqualDivpp(i)).time(end-clip)-Data(EqualDivpp(i)).time(1)+1)=Data(EqualDivpp(i)).prec(1:end-clip);
        savPCells(11).c(i,1:Data(EqualDivpp(i)).time(end-clip)-Data(EqualDivpp(i)).time(1)+1)=cumsum(Data(EqualDivpp(i)).prec(1:end-clip));
    end
end

% Twins that both do not divide
for i=1:length(EqualNoDiv)                
%     plot(Data(EqualDiv(i)).time-Data(EqualDiv(i)).time(1),Data(EqualDiv(i)).area);
    savArea(5).a(i,1:Data(EqualNoDiv(i)).time(end-clip)-Data(EqualNoDiv(i)).time(1)+1)=Data(EqualNoDiv(i)).area(1:end-clip);
    savMigrate(5).a(i,1:Data(EqualNoDiv(i)).time(end-clip)-Data(EqualNoDiv(i)).time(1)+1)=Data(EqualNoDiv(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).t(5).a(i,1:Data(EqualNoDiv(i)).time(end-clip)-Data(EqualNoDiv(i)).time(1)+1)=Data(EqualNoDiv(i)).touch(np).t(1:end-clip);
            savT(np).n(5).a(i,1:Data(EqualNoDiv(i)).time(end-clip)-Data(EqualNoDiv(i)).time(1)+1)=Data(EqualNoDiv(i)).touch(np).n(1:end-clip);
            savT(np).c(5).a(i,1:Data(EqualNoDiv(i)).time(end-clip)-Data(EqualNoDiv(i)).time(1)+1)=cumsum(Data(EqualNoDiv(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(5).a(i,1:Data(EqualNoDiv(i)).time(end-clip)-Data(EqualNoDiv(i)).time(1)+1)=Data(EqualNoDiv(i)).prec(1:end-clip);
        savPCells(5).c(i,1:Data(EqualNoDiv(i)).time(end-clip)-Data(EqualNoDiv(i)).time(1)+1)=cumsum(Data(EqualNoDiv(i)).prec(1:end-clip));
    end
end

% Parent of twins that both do not divide
for i=1:length(EqualNoDivp)                
%     plot(Data(EqualDiv(i)).time-Data(EqualDiv(i)).time(1),Data(EqualDiv(i)).area);
    savArea(10).a(i,1:Data(EqualNoDivp(i)).time(end-clip)-Data(EqualNoDivp(i)).time(1)+1)=Data(EqualNoDivp(i)).area(1:end-clip);
    savMigrate(10).a(i,1:Data(EqualNoDivp(i)).time(end-clip)-Data(EqualNoDivp(i)).time(1)+1)=Data(EqualNoDivp(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).t(10).a(i,1:Data(EqualNoDivp(i)).time(end-clip)-Data(EqualNoDivp(i)).time(1)+1)=Data(EqualNoDivp(i)).touch(np).t(1:end-clip);
            savT(np).n(10).a(i,1:Data(EqualNoDivp(i)).time(end-clip)-Data(EqualNoDivp(i)).time(1)+1)=Data(EqualNoDivp(i)).touch(np).n(1:end-clip);
            savT(np).c(10).a(i,1:Data(EqualNoDivp(i)).time(end-clip)-Data(EqualNoDivp(i)).time(1)+1)=cumsum(Data(EqualNoDivp(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(10).a(i,1:Data(EqualNoDivp(i)).time(end-clip)-Data(EqualNoDivp(i)).time(1)+1)=Data(EqualNoDivp(i)).prec(1:end-clip);
        savPCells(10).c(i,1:Data(EqualNoDivp(i)).time(end-clip)-Data(EqualNoDivp(i)).time(1)+1)=cumsum(Data(EqualNoDivp(i)).prec(1:end-clip));
    end
end

% Parent of Parent of twins that both do not divide
for i=1:length(EqualNoDivpp)                
%     plot(Data(EqualDiv(i)).time-Data(EqualDiv(i)).time(1),Data(EqualDiv(i)).area);
    savArea(13).a(i,1:Data(EqualNoDivpp(i)).time(end-clip)-Data(EqualNoDivpp(i)).time(1)+1)=Data(EqualNoDivpp(i)).area(1:end-clip);
    savMigrate(13).a(i,1:Data(EqualNoDivpp(i)).time(end-clip)-Data(EqualNoDivpp(i)).time(1)+1)=Data(EqualNoDivpp(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).t(13).a(i,1:Data(EqualNoDivpp(i)).time(end-clip)-Data(EqualNoDivpp(i)).time(1)+1)=Data(EqualNoDivpp(i)).touch(np).t(1:end-clip);
            savT(np).n(13).a(i,1:Data(EqualNoDivpp(i)).time(end-clip)-Data(EqualNoDivpp(i)).time(1)+1)=Data(EqualNoDivpp(i)).touch(np).n(1:end-clip);
            savT(np).c(13).a(i,1:Data(EqualNoDivpp(i)).time(end-clip)-Data(EqualNoDivpp(i)).time(1)+1)=cumsum(Data(EqualNoDivpp(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(13).a(i,1:Data(EqualNoDivpp(i)).time(end-clip)-Data(EqualNoDivpp(i)).time(1)+1)=Data(EqualNoDivpp(i)).prec(1:end-clip);
        savPCells(13).c(i,1:Data(EqualNoDivpp(i)).time(end-clip)-Data(EqualNoDivpp(i)).time(1)+1)=cumsum(Data(EqualNoDivpp(i)).prec(1:end-clip));
    end
end

% Twins that unevenly divide
for i=1:length(UnEqualDiv1)             
%       plot(Data(UnEqualDiv1(i)).time-Data(UnEqualDiv1(i)).time(1),Data(UnEqualDiv1(i)).area,'g');
%       plot(Data(UnEqualDiv2(i)).time-Data(UnEqualDiv2(i)).time(1),Data(UnEqualDiv2(i)).area,'k');
    
% plot(Data(UnEqualDiv2(i)).time-Data(UnEqualDiv2(i)).time(1),Data(UnEqualDiv1(i)).area(1:length(Data(UnEqualDiv2(i)).area))-Data(UnEqualDiv2(i)).area,'g');
    savArea(7).a(i,1:Data(UnEqualDiv1(i)).time(end-clip)-Data(UnEqualDiv1(i)).time(1)+1)=Data(UnEqualDiv1(i)).area(1:end-clip);
    savArea(6).a(i,1:Data(UnEqualDiv2(i)).time(end-clip)-Data(UnEqualDiv2(i)).time(1)+1)=Data(UnEqualDiv2(i)).area(1:end-clip);
    savMigrate(7).a(i,1:Data(UnEqualDiv1(i)).time(end-clip)-Data(UnEqualDiv1(i)).time(1)+1)=Data(UnEqualDiv1(i)).migrate(1:end-clip);
    savMigrate(6).a(i,1:Data(UnEqualDiv2(i)).time(end-clip)-Data(UnEqualDiv2(i)).time(1)+1)=Data(UnEqualDiv2(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).n(7).a(i,1:Data(UnEqualDiv1(i)).time(end-clip)-Data(UnEqualDiv1(i)).time(1)+1)=Data(UnEqualDiv1(i)).touch(np).n(1:end-clip);
            savT(np).n(6).a(i,1:Data(UnEqualDiv2(i)).time(end-clip)-Data(UnEqualDiv2(i)).time(1)+1)=Data(UnEqualDiv2(i)).touch(np).n(1:end-clip);
            savT(np).t(7).a(i,1:Data(UnEqualDiv1(i)).time(end-clip)-Data(UnEqualDiv1(i)).time(1)+1)=Data(UnEqualDiv1(i)).touch(np).t(1:end-clip);
            savT(np).t(6).a(i,1:Data(UnEqualDiv2(i)).time(end-clip)-Data(UnEqualDiv2(i)).time(1)+1)=Data(UnEqualDiv2(i)).touch(np).t(1:end-clip);
            savT(np).c(7).a(i,1:Data(UnEqualDiv1(i)).time(end-clip)-Data(UnEqualDiv1(i)).time(1)+1)=cumsum(Data(UnEqualDiv1(i)).touch(np).n(1:end-clip));
            savT(np).c(6).a(i,1:Data(UnEqualDiv2(i)).time(end-clip)-Data(UnEqualDiv2(i)).time(1)+1)=cumsum(Data(UnEqualDiv2(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(7).a(i,1:Data(UnEqualDiv1(i)).time(end-clip)-Data(UnEqualDiv1(i)).time(1)+1)=Data(UnEqualDiv1(i)).prec(1:end-clip);
        savPCells(6).a(i,1:Data(UnEqualDiv2(i)).time(end-clip)-Data(UnEqualDiv2(i)).time(1)+1)=Data(UnEqualDiv2(i)).prec(1:end-clip);
        savPCells(7).c(i,1:Data(UnEqualDiv1(i)).time(end-clip)-Data(UnEqualDiv1(i)).time(1)+1)=cumsum(Data(UnEqualDiv1(i)).prec(1:end-clip));
        savPCells(6).c(i,1:Data(UnEqualDiv2(i)).time(end-clip)-Data(UnEqualDiv2(i)).time(1)+1)=cumsum(Data(UnEqualDiv2(i)).prec(1:end-clip));
    end
end

% Parent of twins that unevenly divide
for i=1:length(UnEqualDivp)
   % if UnEqualDivp(i)~=27
        savArea(9).a(i,1:Data(UnEqualDivp(i)).time(end-clip)-Data(UnEqualDivp(i)).time(1)+1)=Data(UnEqualDivp(i)).area(1:end-clip);
        savMigrate(9).a(i,1:Data(UnEqualDivp(i)).time(end-clip)-Data(UnEqualDivp(i)).time(1)+1)=Data(UnEqualDivp(i)).migrate(1:end-clip);
        if dotouch==1
            for np=1:4
                savT(np).n(9).a(i,1:Data(UnEqualDivp(i)).time(end-clip)-Data(UnEqualDivp(i)).time(1)+1)=Data(UnEqualDivp(i)).touch(np).n(1:end-clip);
                savT(np).t(9).a(i,1:Data(UnEqualDivp(i)).time(end-clip)-Data(UnEqualDivp(i)).time(1)+1)=Data(UnEqualDivp(i)).touch(np).t(1:end-clip);
                savT(np).c(9).a(i,1:Data(UnEqualDivp(i)).time(end-clip)-Data(UnEqualDivp(i)).time(1)+1)=cumsum(Data(UnEqualDivp(i)).touch(np).n(1:end-clip));

            end
        end
        if dopre==1
            savPCells(9).a(i,1:Data(UnEqualDivp(i)).time(end-clip)-Data(UnEqualDivp(i)).time(1)+1)=Data(UnEqualDivp(i)).prec(1:end-clip);
            savPCells(9).c(i,1:Data(UnEqualDivp(i)).time(end-clip)-Data(UnEqualDivp(i)).time(1)+1)=cumsum(Data(UnEqualDivp(i)).prec(1:end-clip));
        end
 %   end
end

% Parent of Parent of twins that unevenly divide
for i=1:length(UnEqualDivpp)
    savArea(12).a(i,1:Data(UnEqualDivpp(i)).time(end-clip)-Data(UnEqualDivpp(i)).time(1)+1)=Data(UnEqualDivpp(i)).area(1:end-clip);
    savMigrate(12).a(i,1:Data(UnEqualDivpp(i)).time(end-clip)-Data(UnEqualDivpp(i)).time(1)+1)=Data(UnEqualDivpp(i)).migrate(1:end-clip);
    if dotouch==1
        for np=1:4
            savT(np).n(12).a(i,1:Data(UnEqualDivpp(i)).time(end-clip)-Data(UnEqualDivpp(i)).time(1)+1)=Data(UnEqualDivpp(i)).touch(np).n(1:end-clip);
            savT(np).t(12).a(i,1:Data(UnEqualDivpp(i)).time(end-clip)-Data(UnEqualDivpp(i)).time(1)+1)=Data(UnEqualDivpp(i)).touch(np).t(1:end-clip);
            savT(np).c(12).a(i,1:Data(UnEqualDivpp(i)).time(end-clip)-Data(UnEqualDivpp(i)).time(1)+1)=cumsum(Data(UnEqualDivpp(i)).touch(np).n(1:end-clip));
        end
    end
    if dopre==1
        savPCells(12).a(i,1:Data(UnEqualDivpp(i)).time(end-clip)-Data(UnEqualDivpp(i)).time(1)+1)=Data(UnEqualDivpp(i)).prec(1:end-clip);
        savPCells(12).c(i,1:Data(UnEqualDivpp(i)).time(end-clip)-Data(UnEqualDivpp(i)).time(1)+1)=cumsum(Data(UnEqualDivpp(i)).prec(1:end-clip));
    end
end

typelengths(1)=count1;   typelengths(2)=count2;   typelengths(3)=count3;
for j=1:3
       savArea(j).a=savArea(j).a(1:typelengths(j),:);
       savMigrate(j).a=savMigrate(j).a(1:typelengths(j),:);
       if dotouch==1
        for np=1:4
            savT(np).n(j).a=savT(np).n(j).a(1:typelengths(j),:);
            savT(np).t(j).a=savT(np).t(j).a(1:typelengths(j),:);
            savT(np).c(j).a=savT(np).c(j).a(1:typelengths(j),:);
        end
       end
    if dopre==1
        savPCells(j).a=savPCells(j).a(1:typelengths(j),:);
        savPCells(j).c=savPCells(j).a(1:typelengths(j),:);
    end 
end





% for j=4:5
%     figure(1030)
%     hold on
%     for i=1:typelengths(j)
%         
% %         plot((1:length(savT(4).n(j).a(i,:)))./timepointfix,cumsum(savT(4).n(j).a(i,:)),colors{j})
%         plot((1:length(savT(4).n(j).a(i,savArea(j).a(i,:)~=0)))./timepointfix,savT(4).c(j).a(i,savArea(j).a(i,:)~=0),colors{j})
%     end
% %     for i=1:timepts
% %         avgCS(j).a(i)=mean(cumsum(savT(4).n(j).a(:,i))
% %     end
%     
% end
dullC={[0 .6 0],[.6 0 0],[.8 .8 0],[.8 .4 0],[0 .6 0],[.6 0 0],[.8 .8 0],[.8 .4 0],[0 .6 0],[.6 0 0],[.8 .8 0],[.8 .4 0],[0 .6 0],[.6 0 0],[.8 .8 0],[.8 .4 0]};
clear avgA semA avgT semT avgPC semPC avgPC2 semPC2 avgM semM len
for j=13:-1:4
    for i=1:timepts-1
        len(j).a(i)=length(savArea(j).a(savArea(j).a(:,i)~=0,i)); %#  of cells that meet each condition at given timept 
        avgA(j).a(i)=mean(savArea(j).a(savArea(j).a(:,i)~=0,i));
        semA(j).a(i)=std(savArea(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
        avgM(j).a(i)=mean(savMigrate(j).a(savArea(j).a(:,i)~=0,i));
        semM(j).a(i)=std(savMigrate(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
        if dotouch==1
            for np=1:4
                avgT(np).n(j).a(i)=mean(savT(np).n(j).a(savArea(j).a(:,i)~=0,i));
                semT(np).n(j).a(i)=std(savT(np).n(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
                avgT(np).t(j).a(i)=mean(savT(np).t(j).a(savArea(j).a(:,i)~=0,i));
                semT(np).t(j).a(i)=std(savT(np).t(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
                avgT(np).c(j).a(i)=mean(savT(np).c(j).a(savArea(j).a(:,i)~=0,i));
                semT(np).c(j).a(i)=std(savT(np).c(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
            end
        end
        if dopre==1
            avgPC(j).a(i)=mean(savPCells(j).a(savArea(j).a(:,i)~=0,i));
            semPC(j).a(i)=std(savPCells(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
            avgPC(j).c(i)=mean(savPCells(j).c(savArea(j).a(:,i)~=0,i));
            semPC(j).c(i)=std(savPCells(j).c(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
            avgPC(j).d(i)=mean(savPCells(j).c(savArea(j).a(:,i)~=0,i)./savArea(j).a(savArea(j).a(:,i)~=0,i));
            semPC(j).d(i)=std(savPCells(j).c(savArea(j).a(:,i)~=0,i)./savArea(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
            avgPC2(j).a(i)=mean(savPCells(j).a(savArea(j).a(:,i)~=0,i)./savArea(j).a(savArea(j).a(:,i)~=0,i));
            semPC2(j).a(i)=std(savPCells(j).a(savArea(j).a(:,i)~=0,i)./savArea(j).a(savArea(j).a(:,i)~=0,i))./sqrt(length(savArea(j).a(savArea(j).a(:,i)~=0,i)));
        end
    end
    
    avgA(j).a=avgA(j).a(isfinite(avgA(j).a));
    semA(j).a=semA(j).a(isfinite(semA(j).a));
    avgM(j).a=avgM(j).a(isfinite(avgM(j).a));
    semM(j).a=semM(j).a(isfinite(semM(j).a));
    if dotouch==1
        for np=1:4
            avgT(np).n(j).a=avgT(np).n(j).a(isfinite(avgT(np).n(j).a));
            semT(np).n(j).a=semT(np).n(j).a(isfinite(semT(np).n(j).a));
            avgT(np).t(j).a=avgT(np).t(j).a(isfinite(avgT(np).t(j).a));
            semT(np).t(j).a=semT(np).t(j).a(isfinite(semT(np).t(j).a));
            avgT(np).c(j).a=avgT(np).c(j).a(isfinite(avgT(np).c(j).a));
            semT(np).c(j).a=semT(np).c(j).a(isfinite(semT(np).c(j).a));
        end
    end
    if dopre==1
        avgPC(j).a=avgPC(j).a(isfinite(avgPC(j).a));
        semPC(j).a=semPC(j).a(isfinite(semPC(j).a));
        avgPC(j).c=avgPC(j).c(isfinite(avgPC(j).c));
        semPC(j).c=semPC(j).c(isfinite(semPC(j).c));
        avgPC(j).d=avgPC(j).d(isfinite(avgPC(j).d));
        semPC(j).d=semPC(j).d(isfinite(semPC(j).d));
        avgPC2(j).a=avgPC2(j).a(isfinite(avgPC2(j).a));
        semPC2(j).a=semPC2(j).a(isfinite(semPC2(j).a));
    end
    
%     figure(5000)
%     hold on
%      plot(avgPC(4).d,'k')
%     plot(avgPC(5).d,'k')

    
    figure(1020)
    hold on
    patch([(1:length(avgA(j).a))./timepointfix fliplr((1:length(avgA(j).a))./timepointfix)],[avgA(j).a+semA(j).a fliplr(avgA(j).a-semA(j).a)],dullC{j-3}+.2,'EdgeColor','none');
    plot((1:length(avgA(j).a))./timepointfix,avgA(j).a,'Color',dullC{j-3})
%     plot((1:length(avgA(j).a))./timepointfix,avgA(j).a+semA(j).a,colors{j})
%     plot((1:length(avgA(j).a))./timepointfix,avgA(j).a-semA(j).a,colors{j})
%     errorbar((1:length(avgA(j).a))./timepointfix,avgA(j).a,semA(j).a,colors{j})
    title('Avg area over time')
    xlabel('time')
    ylabel('um^2')
     
    figure(1021)
    if dotouch==1
        for np=1:4
            subplot(2,2,np); hold on; title('Avg number touching cells over time'); xlabel('time'); ylabel('#'); xlim([0 2])
            patch([(1:length(avgT(np).n(j).a))./timepointfix fliplr((1:length(avgT(np).n(j).a))./timepointfix)],[avgT(np).n(j).a+semT(np).n(j).a fliplr(avgT(np).n(j).a-semT(np).n(j).a)],dullC{j-3}+.2,'EdgeColor','none');
            plot((1:length(avgT(np).n(j).a))./timepointfix,avgT(np).n(j).a,'Color',dullC{j-3})
    %         plot((1:length(avgT(np).n(j).a))./timepointfix,avgT(np).n(j).a+semT(np).n(j).a,colors{j})
    %         plot((1:length(avgT(np).n(j).a))./timepointfix,avgT(np).n(j).a-semT(np).n(j).a,colors{j})
    %         errorbar((1:length(avgT(np).n(j).a))./timepointfix,avgT(np).n(j).a,semT(np).n(j).a,colors{j})
        end
    end
    figure(1033)
    hold on
        patch([(1:length(avgM(j).a))./timepointfix fliplr((1:length(avgM(j).a))./timepointfix)],[avgM(j).a+semM(j).a fliplr(avgM(j).a-semM(j).a)],dullC{j-3}+.2,'EdgeColor','none');
        plot((1:length(avgM(j).a))./timepointfix,avgM(j).a,'Color',dullC{j-3})
%     plot((1:length(avgM(j).a))./timepointfix,avgM(j).a+semM(j).a,colors{j})
%     plot((1:length(avgM(j).a))./timepointfix,avgM(j).a-semM(j).a,colors{j})
%     errorbar((1:length(avgM(j).a))./timepointfix,avgM(j).a,semM(j).a,colors{j})
    title('Avg migration speed over time')
    xlabel('time')
    ylabel('um/s')
    
        figure(1030)
        if dotouch==1
            for np=1:4
                subplot(2,2,np); hold on; title('Cumulative avg number touching cells over time'); xlabel('time'); ylabel('#'); xlim([0 2])
                patch([(1:length(avgT(np).c(j).a))./timepointfix fliplr((1:length(avgT(np).c(j).a))./timepointfix)],[avgT(np).c(j).a+semT(np).c(j).a fliplr(avgT(np).c(j).a-semT(np).c(j).a)],dullC{j-3}+.2,'EdgeColor','none');
                plot((1:length(avgT(np).c(j).a))./timepointfix,avgT(np).c(j).a,'Color',dullC{j-3})
        %         plot((1:length(avgT(np).c(j).a))./timepointfix,avgT(np).c(j).a+semT(np).c(j).a,colors{j})
        %         plot((1:length(avgT(np).c(j).a))./timepointfix,avgT(np).c(j).a-semT(np).c(j).a,colors{j})
        %         errorbar((1:length(avgT(np).c(j).a))./timepointfix,avgT(np).c(j).a,semT(np).c(j).a,colors{j})
            end
        end
    
%     figure(1025)
%     hold on
%     plot((1:length(avgNT(j).a))./timepointfix,mean(cumsum(savNTouch(j).a)),colors{j})

    figure(1022)
    if dotouch==1
        for np=1:4
            subplot(2,2,np); hold on; title('Avg %touching cells over time'); xlabel('time'); ylabel('#'); xlim([0 2])

    %         plot((1:length(avgT(np).t(j).a))./timepointfix,avgT(np).t(j).a+semT(np).t(j).a,colors{j})
    %         plot((1:length(avgT(np).t(j).a))./timepointfix,avgT(np).t(j).a-semT(np).t(j).a,colors{j})
    %         errorbar((1:length(avgT(np).t(j).a))./timepointfix,avgT(np).t(j).a,semT(np).t(j).a,colors{j})
            patch([(1:length(avgT(np).t(j).a))./timepointfix fliplr((1:length(avgT(np).t(j).a))./timepointfix)],[avgT(np).t(j).a+semT(np).t(j).a fliplr(avgT(np).t(j).a-semT(np).t(j).a)],dullC{j-3}+.2,'EdgeColor','none');
            plot((1:length(avgT(np).t(j).a))./timepointfix,avgT(np).t(j).a,'Color',dullC{j-3})
        end
    end
       
    if dopre==1
        figure(1023)
        hold on
        patch([(1:length(avgPC(j).a))./timepointfix fliplr((1:length(avgPC(j).a))./timepointfix)],[avgPC(j).a+semPC(j).a fliplr(avgPC(j).a-semPC(j).a)],dullC{j-3}+.2,'EdgeColor','none');
        plot((1:length(avgPC(j).a))./timepointfix,avgPC(j).a,'Color',dullC{j-3})
%         plot((1:length(avgPC(j).a))./timepointfix,avgPC(j).a+semPC(j).a,colors{j})
%         plot((1:length(avgPC(j).a))./timepointfix,avgPC(j).a-semPC(j).a,colors{j})
%         errorbar((1:length(avgPC(j).a))./timepointfix,avgPC(j).a,semPC(j).a,colors{j})
        title('Avg previous cell contact over time')
        xlabel('time')
        ylabel('summed pixels')
        figure(1024)
        hold on
        patch([(1:length(avgPC2(j).a))./timepointfix fliplr((1:length(avgPC2(j).a))./timepointfix)],[avgPC2(j).a+semPC2(j).a fliplr(avgPC2(j).a-semPC2(j).a)],dullC{j-3}+.2,'EdgeColor','none');
        plot((1:length(avgPC2(j).a))./timepointfix,avgPC2(j).a,'Color',dullC{j-3})
%         plot((1:length(avgPC2(j).a))./timepointfix,avgPC2(j).a+semPC2(j).a,colors{j})
%         plot((1:length(avgPC2(j).a))./timepointfix,avgPC2(j).a-semPC2(j).a,colors{j})
%         errorbar((1:length(avgPC(j).a))./timepointfix,avgPC2(j).a,semPC2(j).a,colors{j})
        title('Avg previous cell contact/cell area over time')
        xlabel('time')
        ylabel('fraction')
        figure(1050)
        hold on
        patch([(1:length(avgPC(j).c))./timepointfix fliplr((1:length(avgPC(j).c))./timepointfix)],[avgPC(j).c+semPC(j).c fliplr(avgPC(j).c-semPC(j).c)],dullC{j-3}+.2,'EdgeColor','none');
        plot((1:length(avgPC(j).c))./timepointfix,avgPC(j).c,'Color',dullC{j-3})
%         plot((1:length(avgPC(j).c))./timepointfix,avgPC(j).c+semPC(j).c,colors{j})
%         plot((1:length(avgPC(j).c))./timepointfix,avgPC(j).c-semPC(j).c,colors{j})
%         errorbar((1:length(avgPC(j).c))./timepointfix,avgPC(j).c,semPC(j).c,colors{j})
        title('Cummulative previous cell contact over time')
        xlabel('time')
        ylabel('summed pixels')
        figure(1051)
        hold on
        patch([(1:length(avgPC(j).d))./timepointfix fliplr((1:length(avgPC(j).d))./timepointfix)],[avgPC(j).d+semPC(j).d fliplr(avgPC(j).d-semPC(j).d)],dullC{j-3}+.2,'EdgeColor','none');
        plot((1:length(avgPC(j).d))./timepointfix,avgPC(j).d,'Color',dullC{j-3})
%         plot((1:length(avgPC(j).c))./timepointfix,avgPC(j).c+semPC(j).c,colors{j})
%         plot((1:length(avgPC(j).c))./timepointfix,avgPC(j).c-semPC(j).c,colors{j})
%         errorbar((1:length(avgPC(j).c))./timepointfix,avgPC(j).c,semPC(j).c,colors{j})
        title('Cummulative previous cell contact over time/cell area')
        xlabel('time')
        ylabel('summed pixels')
    end
end

% % %     ang=0:0.01:2*pi;
% % %     rr=.5/pi+(avgA(2).a(floor(ang./(2*pi)*timepointfix)+1)-1400)/50000;
% % %     xc=-rr.*cos(ang+pi/2);
% % %     yc=rr.*sin(ang+pi/2);
% % %     rr2=.5/pi-(avgA(2).a(floor(ang./(2*pi)*timepointfix)+1)-1400)/50000;
% % %     xc2=-rr2.*cos(ang+pi/2);
% % %     yc2=rr2.*sin(ang+pi/2);
% % %     figure(2)
% % %     hold on
% % %     for circ=1:length(xc)-1
% % % %         plot([xc(circ) xc(circ+1)],[yc(circ) yc(circ+1)],'b','LineWidth',avgA(j).a(floor(ang(circ)/(2*pi)*timepointfix)+1)/300)
% % %         plot(xc,yc,'b')
% % %         plot(xc2,yc2,'b')
% % %         patch([xc fliplr(xc2)],[yc fliplr(yc2)],[.5 .5 1],'EdgeColor','b');
% % %     end
% % % %     axis([-11 11 -11 11])
% % % %     hold on
% % % %     plot(avgA(2).a(1:49),'b','LineWidth',1)
% % % %     plot(avgA(j).a(floor(ang./(2*pi)*timepointfix)+1),'b','LineWidth',1)
% % %         hold on
% % % %     plot((10+(20*pi*4)/192):(20*pi*4)/192:(20*pi*4)+10,10+(avgA(3).a(1:192)-1400)/5000,'r','LineWidth',1)
% % % %     plot((10+(20*pi*4)/192):(20*pi*4)/192:(20*pi*4)+10,10-(avgA(3).a(1:192)-1400)/5000,'r','LineWidth',1)
% % %     patch([(4/192:4/192:4) fliplr(4/192:4/192:4)],[.25+(avgA(3).a(1:192)-1400)/50000 fliplr(.25-(avgA(3).a(1:192)-1400)/50000)],[1 .5 .5],'EdgeColor','r');
% % %  
% % % %     plot((10+40/192):40/192:40+10,10+(avgA(3).a(1:192)-1400)/2500,'r','LineWidth',1)
% % % %     plot((10+40/192):40/192:40+10,10-(avgA(3).a(1:192)-1400)/2500,'r','LineWidth',1)
% % % %     patch([(10+40/192):40/192:40+10 fliplr((10+40/192):40/192:40+10)],[10+(avgA(3).a(1:192)-1400)/2500 fliplr(10-(avgA(3).a(1:192)-1400)/2500)],[1 .5 .5],'EdgeColor','r');
% % %     
% % %     ang=0:0.01:2*pi;
% % %     rr=(avgA(2).a(floor(ang./(2*pi)*timepointfix)+1));
% % %     xc=-rr.*cos(ang+pi/2);
% % %     yc=rr.*sin(ang+pi/2);
% % %     ang2=horzcat(ang,ang,ang,ang);
% % %     rr2=horzcat((avgA(3).a(floor(ang./(2*pi)*timepointfix)+1)),(avgA(3).a(floor(ang./(2*pi)*timepointfix)+49)),(avgA(3).a(floor(ang./(2*pi)*timepointfix)+97)),(avgA(3).a(floor(ang./(2*pi)*timepointfix)+145)));
% % %     xc2=-rr2.*cos(ang2+pi/2);
% % %     yc2=rr2.*sin(ang2+pi/2);
% % %     figure(1)
% % %     hold on
% % %     for circ=1:length(xc)-1
% % % %         plot([xc(circ) xc(circ+1)],[yc(circ) yc(circ+1)],'b','LineWidth',avgA(j).a(floor(ang(circ)/(2*pi)*timepointfix)+1)/300)
% % %         plot(xc,yc,'b')
% % %         plot(xc2,yc2,'r')
% % % %         area(Data(children(i)).time/timepointfix,Data(children(i)).area./5e5+Cl(i),'FaceColor',splitC2{Data(children(i)).gen},'BaseValue',Cl(i))
% % %     end 
% % %     plot(0,0,'k')
% % %     
    
% Average and SEM lifetimes    
avgL=zeros(1,13);
semL=zeros(1,13);
% Lifetimes of twins that both divide split into two groups
[v,ai4,ib]=intersect(genname,EqualDiv);
avgL(3)=round(mean(lifetime(ai4(1:2:end))));
semL(3)=(std(lifetime(ai4(1:2:end))))/sqrt(length(lifetime(ai4(1:2:end))));
avgL(4)=round(mean(lifetime(ai4(2:2:end))));
semL(4)=(std(lifetime(ai4(2:2:end))))/sqrt(length(lifetime(ai4(2:2:end))));
% Lifetimes of twins that both no not divide
[v,ai,ib]=intersect(genname,EqualNoDiv);
avgL(5)=round(mean(lifetime(ai)));
semL(5)=(std(lifetime(ai)))/sqrt(length(lifetime(ai)));
[v,ai6,ib]=intersect(genname,UnEqualDiv2);
avgL(6)=round(mean(lifetime(ai6)));
semL(6)=(std(lifetime(ai6)))/sqrt(length(lifetime(ai6)));
[v,ai,ib]=intersect(genname,UnEqualDiv1);
avgL(7)=round(mean(lifetime(ai)));
semL(7)=(std(lifetime(ai)))/sqrt(length(lifetime(ai)));
[h,p,ci,stats] = ttest2(lifetime(ai4(1:2:end)),lifetime(ai6));

clear indvmean indvsem
np=2;
for i=1:len(4).a(1)
	indvmean(4).a(i)=mean(savArea(4).a(i,(savArea(4).a(i,:)~=0)));
    %     indvsem(4).a(i)=std(savArea(4).a(i,(savArea(4).a(i,:)~=0)))/sqrt(length(savArea(4).a(i,(savArea(4).a(i,:)~=0))));
    if dotouch==1
        indvmean(4).t(i)=mean(savT(np).t(4).a(i,(savArea(4).a(i,:)~=0)));
        indvmean(4).n(i)=mean(savT(np).n(4).a(i,(savArea(4).a(i,:)~=0)));
        indvmean(4).c(i)=max(savT(np).c(4).a(i,(savArea(4).a(i,:)~=0)));
        %     indvsem(4).t(i)=std(savT(np).t(4).a(i,(savArea(4).a(i,:)~=0)))/sqrt(length(savT(np).t(4).a(i,(savArea(4).a(i,:)~=0))));
        %     indvsem(4).n(i)=std(savT(np).n(4).a(i,(savArea(4).a(i,:)~=0)))/sqrt(length(savT(np).n(4).a(i,(savArea(4).a(i,:)~=0))));
        %     indvsem(4).c(i)=std(savT(np).c(4).a(i,(savArea(4).a(i,:)~=0)))/sqrt(length(savT(np).c(4).a(i,(savArea(4).a(i,:)~=0))));
    end
    if dopre == 1
        indvmean(4).p(i)=mean(savPCells(4).a(i,(savArea(4).a(i,:)~=0)));
        indvmean(4).p2(i)=mean(savPCells(4).a(i,(savArea(4).a(i,:)~=0))./savArea(4).a(i,(savArea(4).a(i,:)~=0)));
    %     indvmean(4).p3(i)=max(savPCells(4).c(i,(savArea(4).a(i,:)~=0)))./indvmean(4).a(i);
        indvmean(4).p3(i)=max(savPCells(4).c(i,(savArea(4).a(i,:)~=0))./savArea(4).a(i,(savArea(4).a(i,:)~=0)));
    end
end


for i=1:len(5).a(1)
    indvmean(5).a(i)=mean(savArea(5).a(i,1:avgL(4)));
    %     indvsem(5).a(i)=std(savArea(5).a(i,1:avgL(4)))/sqrt(length(savArea(5).a(i,1:avgL(4))));
    if dotouch==1
        indvmean(5).t(i)=mean(savT(np).t(5).a(i,1:avgL(4)));
        indvmean(5).n(i)=mean(savT(np).n(5).a(i,1:avgL(4)));
        indvmean(5).c(i)=max(savT(np).c(5).a(i,1:avgL(4)));
        %     indvsem(5).t(i)=std(savT(np).t(5).a(i,1:avgL(4)))/sqrt(length(savT(np).t(5).a(i,1:avgL(4))));
        %     indvsem(5).n(i)=std(savT(np).n(5).a(i,1:avgL(4)))/sqrt(length(savT(np).n(5).a(i,1:avgL(4))));
        %     indvsem(5).c(i)=std(savT(np).c(5).a(i,1:avgL(4)))/sqrt(length(savT(np).c(5).a(i,1:avgL(4))));
    end
    if dopre == 1
        indvmean(5).p(i)=mean(savPCells(5).a(i,1:avgL(4)));
        indvmean(5).p2(i)=mean(savPCells(5).a(i,1:avgL(4))./savArea(5).a(i,1:avgL(4)));
    %     indvmean(5).p3(i)=max(savPCells(5).c(i,1:avgL(4)))./indvmean(5).a(i);
        indvmean(5).p3(i)=max(savPCells(5).c(i,1:avgL(4))./savArea(5).a(i,1:avgL(4)));
    end
end

for i=1:len(6).a(1)
	indvmean(6).a(i)=mean(savArea(6).a(i,(savArea(6).a(i,:)~=0)));
    indvmean(7).a(i)=mean(savArea(7).a(i,(savArea(6).a(i,:)~=0)));        
    %     indvsem(6).a(i)=std(savArea(6).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savArea(6).a(i,(savArea(6).a(i,:)~=0))));
    %     indvsem(7).a(i)=std(savArea(7).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savArea(7).a(i,(savArea(6).a(i,:)~=0))));
    if dotouch==1
        indvmean(6).t(i)=mean(savT(np).t(6).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(7).t(i)=mean(savT(np).t(7).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(6).n(i)=mean(savT(np).n(6).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(7).n(i)=mean(savT(np).n(7).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(6).c(i)=max(savT(np).c(6).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(7).c(i)=max(savT(np).c(7).a(i,(savArea(6).a(i,:)~=0)));    
    %     indvsem(6).t(i)=std(savT(np).t(6).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savT(np).t(6).a(i,(savArea(6).a(i,:)~=0))));
    %     indvsem(7).t(i)=std(savT(np).t(7).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savT(np).t(7).a(i,(savArea(6).a(i,:)~=0))));
    %     indvsem(6).n(i)=std(savT(np).n(6).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savT(np).n(6).a(i,(savArea(6).a(i,:)~=0))));
    %     indvsem(7).n(i)=std(savT(np).n(7).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savT(np).n(7).a(i,(savArea(6).a(i,:)~=0))));
    %     indvsem(6).c(i)=std(savT(np).c(6).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savT(np).c(6).a(i,(savArea(6).a(i,:)~=0))));
    %     indvsem(7).c(i)=std(savT(np).c(7).a(i,(savArea(6).a(i,:)~=0)))/sqrt(length(savT(np).c(7).a(i,(savArea(6).a(i,:)~=0))));
    end
    if dopre == 1
        indvmean(6).p(i)=mean(savPCells(6).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(7).p(i)=mean(savPCells(7).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(6).p2(i)=mean(savPCells(6).a(i,(savArea(6).a(i,:)~=0))./savArea(6).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(7).p2(i)=mean(savPCells(7).a(i,(savArea(6).a(i,:)~=0))./savArea(7).a(i,(savArea(6).a(i,:)~=0)));
    %     indvmean(6).p3(i)=max(savPCells(6).c(i,(savArea(6).a(i,:)~=0)))./indvmean(6).a(i);
    %     indvmean(7).p3(i)=max(savPCells(7).c(i,(savArea(6).a(i,:)~=0)))./indvmean(7).a(i);

        indvmean(6).p3(i)=max(savPCells(6).c(i,(savArea(6).a(i,:)~=0))./savArea(6).a(i,(savArea(6).a(i,:)~=0)));
        indvmean(7).p3(i)=max(savPCells(7).c(i,(savArea(6).a(i,:)~=0))./savArea(7).a(i,(savArea(6).a(i,:)~=0)));
    end


end

if dopre==1
    [h,p,ci,stats] = ttest2(indvmean(4).p3,indvmean(5).p3)
end

dullC={[0 .6 0],[.8 .8 0],[.8 .4 0],[.6 0 0]};
if dotouch==1
    figure(11112)
    % subplot(2,2,1); hold on
    % % barwitherr([std(indvmean(4).a)/sqrt(length(indvmean(4).a)),std(indvmean(6).a)/sqrt(length(indvmean(6).a)),std(indvmean(7).a)/sqrt(length(indvmean(7).a)),std(indvmean(5).a)/sqrt(length(indvmean(5).a))],[mean(indvmean(4).a),mean(indvmean(6).a),mean(indvmean(7).a),mean(indvmean(5).a)])
    % bar(1,mean(indvmean(4).a),'FaceColor',dullC{1}); bar(2,mean(indvmean(6).a),'FaceColor',dullC{2}); bar(3,mean(indvmean(7).a),'FaceColor',dullC{3}); bar(4,mean(indvmean(5).a),'FaceColor',dullC{4})
    % errorbar([1 2 3 4],[mean(indvmean(4).a),mean(indvmean(6).a),mean(indvmean(7).a),mean(indvmean(5).a)],[std(indvmean(4).a)/sqrt(length(indvmean(4).a)),std(indvmean(6).a)/sqrt(length(indvmean(6).a)),std(indvmean(7).a)/sqrt(length(indvmean(7).a)),std(indvmean(5).a)/sqrt(length(indvmean(5).a))],'LineStyle','none','Color','k')
    % ylabel('Mean Cell Area'); xlim([0 5])
    subplot(2,2,3); hold on
    bar(1,mean(indvmean(4).t),'FaceColor',dullC{1}); bar(2,mean(indvmean(6).t),'FaceColor',dullC{2}); bar(3,mean(indvmean(7).t),'FaceColor',dullC{3}); bar(4,mean(indvmean(5).t),'FaceColor',dullC{4})
    errorbar([1 2 3 4],[mean(indvmean(4).t),mean(indvmean(6).t),mean(indvmean(7).t),mean(indvmean(5).t)],[std(indvmean(4).t)/sqrt(length(indvmean(4).t)),std(indvmean(6).t)/sqrt(length(indvmean(6).t)),std(indvmean(7).t)/sqrt(length(indvmean(7).t)),std(indvmean(5).t)/sqrt(length(indvmean(5).t))],'LineStyle','none','Color','k')
    ylabel('Mean % Cell Contact'); xlim([0 5])
    subplot(2,2,1); hold on
    bar(1,mean(indvmean(4).n),'FaceColor',dullC{1}); bar(2,mean(indvmean(6).n),'FaceColor',dullC{2}); bar(3,mean(indvmean(7).n),'FaceColor',dullC{3}); bar(4,mean(indvmean(5).n),'FaceColor',dullC{4})
    errorbar([1 2 3 4],[mean(indvmean(4).n),mean(indvmean(6).n),mean(indvmean(7).n),mean(indvmean(5).n)],[std(indvmean(4).n)/sqrt(length(indvmean(4).n)),std(indvmean(6).n)/sqrt(length(indvmean(6).n)),std(indvmean(7).n)/sqrt(length(indvmean(7).n)),std(indvmean(5).n)/sqrt(length(indvmean(5).n))],'LineStyle','none','Color','k')
    ylabel('Mean # Cell Contact'); xlim([0 5])
    subplot(2,2,2); hold on
    bar(1,mean(indvmean(4).c),'FaceColor',dullC{1}); bar(2,mean(indvmean(6).c),'FaceColor',dullC{2}); bar(3,mean(indvmean(7).c),'FaceColor',dullC{3}); bar(4,mean(indvmean(5).c),'FaceColor',dullC{4})
    errorbar([1 2 3 4],[mean(indvmean(4).c),mean(indvmean(6).c),mean(indvmean(7).c),mean(indvmean(5).c)],[std(indvmean(4).c)/sqrt(length(indvmean(4).c)),std(indvmean(6).c)/sqrt(length(indvmean(6).c)),std(indvmean(7).c)/sqrt(length(indvmean(7).c)),std(indvmean(5).c)/sqrt(length(indvmean(5).c))],'LineStyle','none','Color','k')
    ylabel('Cumulative Cell Contact'); xlim([0 5])
end

if dopre==1
    % bar(1,mean(indvmean(4).p),'FaceColor','g'); bar(2,mean(indvmean(6).p),'FaceColor','y'); bar(3,mean(indvmean(7).p),'FaceColor',[1 .5 0]); bar(4,mean(indvmean(5).p),'FaceColor','r')
    % errorbar([1 2 3 4],[mean(indvmean(4).p),mean(indvmean(6).p),mean(indvmean(7).p),mean(indvmean(5).p)],[std(indvmean(4).p)/sqrt(length(indvmean(4).p)),std(indvmean(6).p)/sqrt(length(indvmean(6).p)),std(indvmean(7).p)/sqrt(length(indvmean(7).p)),std(indvmean(5).p)/sqrt(length(indvmean(5).p))],'LineStyle','none','Color','k')
    % ylabel('Mean Previous Cell Precence'); xlim([0 5])

    % subplot(2,2,4); hold on
    % hold on
    % bar(1,mean(indvmean(4).p2),'FaceColor',dullC{1}); bar(2,mean(indvmean(6).p2),'FaceColor',dullC{2}); bar(3,mean(indvmean(7).p2),'FaceColor',dullC{3}); bar(4,mean(indvmean(5).p2),'FaceColor',dullC{4})
    % errorbar([1 2 3 4],[mean(indvmean(4).p2),mean(indvmean(6).p2),mean(indvmean(7).p2),mean(indvmean(5).p2)],[std(indvmean(4).p2)/sqrt(length(indvmean(4).p2)),std(indvmean(6).p2)/sqrt(length(indvmean(6).p2)),std(indvmean(7).p2)/sqrt(length(indvmean(7).p2)),std(indvmean(5).p2)/sqrt(length(indvmean(5).p2))],'LineStyle','none','Color','k')
    % ylabel('Mean Previous Cell Presence'); xlim([0 5])

    subplot(2,2,4); hold on
    hold on
    bar(1,mean(indvmean(4).p3),'FaceColor',dullC{1}); bar(2,mean(indvmean(6).p3),'FaceColor',dullC{2}); bar(3,mean(indvmean(7).p3),'FaceColor',dullC{3}); bar(4,mean(indvmean(5).p3),'FaceColor',dullC{4})
    errorbar([1 2 3 4],[mean(indvmean(4).p3),mean(indvmean(6).p3),mean(indvmean(7).p3),mean(indvmean(5).p3)],[std(indvmean(4).p3)/sqrt(length(indvmean(4).p3)),std(indvmean(6).p3)/sqrt(length(indvmean(6).p3)),std(indvmean(7).p3)/sqrt(length(indvmean(7).p3)),std(indvmean(5).p3)/sqrt(length(indvmean(5).p3))],'LineStyle','none','Color','k')
    ylabel('Mean Previous Cell Presence'); xlim([0 5])
end

[v,ai8,ib]=intersect(genname,EqualDivp);
avgL(8)=round(mean(lifetime(ai8)));
semL(8)=(std(lifetime(ai8)))/sqrt(length(lifetime(ai8)));
[v,ai,ib]=intersect(genname,EqualDivpp);
avgL(11)=round(mean(lifetime(ai)));
semL(11)=(std(lifetime(ai)))/sqrt(length(lifetime(ai)));
[v,ai10,ib]=intersect(genname,EqualNoDivp);
avgL(10)=round(mean(lifetime(ai10)));
semL(10)=(std(lifetime(ai10)))/sqrt(length(lifetime(ai10)));
[v,ai,ib]=intersect(genname,EqualNoDivpp);
avgL(13)=round(mean(lifetime(ai)));
semL(13)=(std(lifetime(ai)))/sqrt(length(lifetime(ai)));
[v,ai9,ib]=intersect(genname,UnEqualDivp);
avgL(9)=round(mean(lifetime(ai9)));
semL(9)=(std(lifetime(ai9)))/sqrt(length(lifetime(ai9)));
[v,ai,ib]=intersect(genname,UnEqualDivpp);
avgL(12)=round(mean(lifetime(ai)));
semL(12)=(std(lifetime(ai)))/sqrt(length(lifetime(ai)));

[h,p,ci,stats] = ttest2(lifetime(ai8),lifetime(ai10));

splitC3={'r','y','g'}; % color code
splitC4={[1 0 0],[1 1 0],[0 1 0]}; % color code
indexnums=[5 5 10 13;6 7 9 12;4 4 8 11];
offS=[.3,-.3,0];
figure(5000)
% k=1 division stops (red), k=2 unequal division (yellow ,orange), k=3 both
% divide (green)
for k=1:1:3
%  figure(k)
    hold on
    C=[1 2 3 4 5 6 7 8];
    
    if (isnan(avgL(indexnums(k,1)))~=1 || k==1) && isempty(avgA(indexnums(k,1)).a)~=1
        if k==1
           range = 1:192;
        else 
            range = 1:avgL(indexnums(k,1));
            if length(range)> length(avgA(indexnums(k,1)).a); range=1:length(avgA(indexnums(k,1)).a); end
        end
        patch([range/timepointfix fliplr(range/timepointfix)],[avgA(indexnums(k,1)).a(range)/5000+C(3) fliplr(-avgA(indexnums(k,1)).a(range)/5000+C(3))],splitC4{k})
        errorbar(range/timepointfix,avgA(indexnums(k,1)).a(range)/5000+C(3),semA(indexnums(k,1)).a(range)/5000,'k')
        errorbar(range/timepointfix,-avgA(indexnums(k,1)).a(range)/5000+C(3),semA(indexnums(k,1)).a(range)/5000,'k')
        plot(range/timepointfix,zeros(length(range),1)+C(3),splitC3{k})
        %h=herrorbar(avgL(indexnums(k,1))/timepointfix,C(3)+offS(k),semL(indexnums(k,1))/timepointfix,semL(indexnums(k,1))/timepointfix);
%         set(h,'color','k','LineWidth',2)
    end

    hold on
    if (isnan(avgL(indexnums(k,2)))~=1 || k==1) && isempty(avgA(indexnums(k,2)).a)~=1
         if k==1
           range = 1:192;
         else 
            range = 1:avgL(indexnums(k,2));
            if length(range)> length(avgA(indexnums(k,2)).a); range=1:length(avgA(indexnums(k,2)).a); end
         end
        patch([range/timepointfix fliplr(range/timepointfix)],[avgA(indexnums(k,2)).a(range)/5000+C(7) fliplr(-avgA(indexnums(k,2)).a(range)/5000+C(7))],splitC4{k})
        errorbar(range/timepointfix,avgA(indexnums(k,2)).a(range)/5000+C(7),semA(indexnums(k,2)).a(range)/5000,'k')
        errorbar(range/timepointfix,-avgA(indexnums(k,2)).a(range)/5000+C(7),semA(indexnums(k,2)).a(range)/5000,'k')
        plot(range/timepointfix,zeros(length(range),1)+C(7),splitC3{k})
       % h=herrorbar(avgL(indexnums(k,2))/timepointfix,C(7)+offS(k),semL(indexnums(k,2))/timepointfix,semL(indexnums(k,2))/timepointfix);
%         set(h,'color','k','LineWidth',2)
    end
      
    hold on
    if isnan(avgL(indexnums(1,3)))~=1 && isnan(avgL(indexnums(k,3)))~=1
        range = -(avgL(indexnums(1,3)):-1:(avgL(indexnums(1,3))-avgL(indexnums(k,3))+1));
        range2=1:avgL(indexnums(k,3));
        if length(range2)> length(avgA(indexnums(k,3)).a) 
            range2=1:length(avgA(indexnums(k,3)).a);
            range=-((avgL(indexnums(1,3))-avgL(indexnums(k,3))+1)+length(range2)-1:-1:(avgL(indexnums(1,3))-avgL(indexnums(k,3))+1));
        end
        patch([range/timepointfix fliplr(range/timepointfix)],[avgA(indexnums(k,3)).a(range2)/5000+C(5) fliplr(-avgA(indexnums(k,3)).a(range2)/5000+C(5))],splitC4{k})
        errorbar(range/timepointfix,avgA(indexnums(k,3)).a(range2)/5000+C(5),semA(indexnums(k,3)).a(range2)/5000,'k')
        errorbar(range/timepointfix,-avgA(indexnums(k,3)).a(range2)/5000+C(5),semA(indexnums(k,3)).a(range2)/5000,'k')
        plot(range/timepointfix,zeros(length(range2),1)+C(5),splitC3{k})
      %  h=herrorbar(-((avgL(indexnums(1,3))-avgL(indexnums(k,3))+1))/timepointfix,C(5)+offS(k),semL(indexnums(k,3))/timepointfix,semL(indexnums(k,3))/timepointfix);
%         set(h,'color','k','LineWidth',2)
    end
    
    if isnan(avgL(indexnums(2,4)))~=1 && isnan(avgL(indexnums(k,4)))~=1 && isnan(avgL(indexnums(1,3)))~=1
        range=(-(avgL(indexnums(2,4)):-1:(avgL(indexnums(2,4))-avgL(indexnums(k,4))+1))-avgL(indexnums(1,3)));
        range2=1:avgL(indexnums(k,4));
        if length(range2)> length(avgA(indexnums(k,4)).a)
            range2=1:length(avgA(indexnums(k,4)).a);
            range=-((avgL(indexnums(2,4))-avgL(indexnums(k,4))+1))-avgL(indexnums(1,3)+length(range2)-1:-1:(avgL(indexnums(2,4))-avgL(indexnums(k,4))+1))-avgL(indexnums(1,3));
        end
        patch([range/timepointfix fliplr(range/timepointfix)],[avgA(indexnums(k,4)).a(range2)/5000+C(2) fliplr(-avgA(indexnums(k,4)).a(range2)/5000+C(2))],splitC4{k})
        errorbar(range/timepointfix,avgA(indexnums(k,4)).a(range2)/5000+C(2),semA(indexnums(k,4)).a(range2)/5000,'k')
        errorbar(range/timepointfix,-avgA(indexnums(k,4)).a(range2)/5000+C(2),semA(indexnums(k,4)).a(range2)/5000,'k')
        plot(range/timepointfix,zeros(length(range2),1)+C(2),splitC3{k})
       % h=herrorbar((-(avgL(indexnums(2,4))-avgL(indexnums(k,4))+1)-avgL(indexnums(1,3)))/timepointfix,C(2)+offS(k),semL(indexnums(k,4))/timepointfix,semL(indexnums(k,4))/timepointfix);
%         set(h,'color','k','LineWclose idth',2)
    end
end
xlabel('Lifetime (1 day per tickmark)')
ylabel('Spread cell area (arbitrary offset and units)')
end
end