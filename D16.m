%% D16 
% calculates properties based on data from 
% CellProfiler and other manually-constructed assay data.  

% D16 creates csvs containing calculated properties of
% every cell in every colony.  Properties include cumulative number of
% neighbors, maximum area, generation, and many more.  

% This code relies on inputing three csvs (which need to have been
% generated by separate analyses).  It requires D10, which
% in turn requres getdata6.

% distance and area are in pixels; time is in time points.  There is code
% elsewhere to convert the tables if so desired.  The csvs are saved with
% and without headers, as is a list of the property names by themselves.

%%
%%%%% inputs %%%%
% where the CellProfiler output files are:
data_path=('C:\');
% where to save the table(s)
save_path = ('C:\');
% what to name the table
save_name = 'colony_analysis';
% flag to also make a table with variable headings
make_table_headers = 1;
% what the senescence csv is; object numbers of cells at final time point
% and whether or not they're senescent.
senescence_table = csvread('C:\senescence.csv');
% what the asynchronous csv is:
async_table = csvread('C:\asynchronous_twins.csv');
% what the divider classification csv is:
divider_table = csvread('C:\progeny_classification.csv');
%%%%%%%%%%%%%%%%%
%%
%set up paths, matricies, etc.
mkdir(save_path, save_name);
save_path = fullfile(save_path,[save_name,'\']);
Files = dir(fullfile(data_path, '*.mat'));

correlation_calculated_properties = [];
% set up an overall cell counter 
cellcount_all = 0;
%%
% Cycle through each colony, perform the analyses needed, and log them in a
% matrix (rows are cells, columns are properties)
for colcount = 1:length(Files)
    
    % go through the file names in the data folder to determine
    % the colony names and load the data files
    FileName = Files(colcount).name; 
    colony_name_start = strfind(FileName,'T4')+7;
    colony_name_end = strfind(FileName,'.mat')-1;
    colony_underscore_name = cellstr(FileName(1:colony_name_end));
    colony_name = strrep(colony_underscore_name, '_', ' ')
    colony_number = str2double(FileName([2 3 5 6])); 
    
    % open the CellProfiler output file 
    load(fullfile(data_path, FileName));
        
    % call get_all_properties function to make the Data array and the
    % all_array.  Colonies which have a cell disappear require a
    % specialized version of get_all_properties.
    if colony_number == 4536
       get_all_properties_v5_el_square_ball
    elseif colony_number == 4352
       get_all_properties_v5_divine_rapier
    elseif colony_number == 4336
       get_all_properties_v5_super_hashtag_wounded
    else
       get_all_properties_v5
    end
    

    
    %%% Create colony-specific tables:  
        % make a table of distance from centroid for each cell (column) at each 
        % time point (row) for the colony
        centroiddistance_table = vertcat(all_array.dist_from_centroid);
        
        % make a table of distance from birthplace for each cell (column) at each 
        % time point (row) for the colony
        birthdistance_table = vertcat(all_array.dist_from_birth);

        % make a table of neighbors for each cell (column) at each 
        % time point (row) for the colony
         neighbor_table = ...
             vertcat(all_array.Neighbors_NumberOfNeighbors_10);

         % make a table of neighbors for each cell (column) at each 
         % time point (row) for the colony
         eccentricity_table = ...
             vertcat(all_array.AreaShape_Eccentricity);

        % make a table of divide sizes for downstream analysis (parent
        % divide size).  Row = cellcount_colony cell:
        divide_size_table = zeros(length(Parents),1);

        % table for senescence info for this colony (can't preallocate, don't
        % know what the size is ahead of time)
        senescence_table_colony = [];
        senescence_tick=0;
        % fill out the colony-specific senescence table.  Column 1 is
           % object number, column 2 is a senescence flag (1 for dividing,
           % 2 for senescent)         
        for senescence_all_counter = 1:size(senescence_table,1)
            if senescence_table(senescence_all_counter,1)==colony_number
               senescence_tick = senescence_tick+1;
               senescence_table_colony(senescence_tick,1)...
                   =senescence_table(senescence_all_counter,2);
               senescence_table_colony(senescence_tick,2)...
                   =senescence_table(senescence_all_counter,3);
            end
        end
       
       % fill out colony-specific divider classification table.  Column 1
       % is the progeny number, column 2 is its classification, column 3 is
       % the cells in its lineage
       divider_rows = find(divider_table == colony_number);
       temp_divider_table = divider_table(divider_rows,:);
       % for each progeny in the colony:
       clear rowcount_divider
       for rowcount_divider = 1:size(divider_rows,1)
           divider_array{rowcount_divider,1} = rowcount_divider;
           divider_array{rowcount_divider,2} = ...
               temp_divider_table(rowcount_divider,5);
           divider_array{rowcount_divider,3} = ...
               (Parents(rowcount_divider).lineage_all);
       end
    %%%  
       

    %%% calculate/add properties to correlation table for each cell in this
    %%% colony
        for cellcount_colony=1:total_cells
            cellcount_all = cellcount_all + 1;
            
            [max_area,max_area_tmpt] = max(Data(cellcount_colony).area);
            
            % 1. max area 
            correlation_calculated_properties(cellcount_all,1) = max_area;
           
            % 2. max area time point
            if isempty(Parents(cellcount_colony).born) %if a starting cell,
            correlation_calculated_properties(cellcount_all,2) = ...
                max_area_tmpt;
            else correlation_calculated_properties(cellcount_all,2) = ...
                max_area_tmpt + Parents(cellcount_colony).born - 1;
            end
            
            % 3. generation
            correlation_calculated_properties(cellcount_all,3) = ...
                Data(cellcount_colony).gen;
            
            % 4. lifetime
            correlation_calculated_properties(cellcount_all,4) = ...
                Parents(cellcount_colony).lifetime; 
            
            % 5. number of progeny
            correlation_calculated_properties(cellcount_all,5) = ...
                length(Parents(cellcount_colony).lineage_all); 
            
            % 6. divide size
            
            % division size is calculated for all dividing cells with the
            % Parents array.  However, it isn't calculated for
            % first-generation cells, so I have to do so here.  1st-gen
            % cells that divide within the first 8 time points of the
            % experiment are still omitted:  
            if Data(cellcount_colony).gen == 1
                if Parents(cellcount_colony).split > 8
                    correlation_calculated_properties(cellcount_all,6) =...
                        mean(Data(cellcount_colony).area(Parents(cellcount_colony).split-4:-1:Parents(cellcount_colony).split-8));
                    % add the value to the divize_size_table, too:
                    divide_size_table(cellcount_colony,1) =... 
                        mean(Data(cellcount_colony).area(Parents(cellcount_colony).split-4:-1:Parents(cellcount_colony).split-8));
                else
                    correlation_calculated_properties(cellcount_all,6) = 0;
                    divide_size_table(cellcount_colony,1) = 0;
                end
            else
                correlation_calculated_properties(cellcount_all,6) = ...
                Parents(cellcount_colony).splitsize; 
                divide_size_table(cellcount_colony,1) = ...
                    Parents(cellcount_colony).splitsize; 
            end
            
            % 7. total distance traveled 
            correlation_calculated_properties(cellcount_all,7) = ...
                Data(cellcount_colony).totaldist(end);    
            
            % Parental properties
            % identify the unique number of the cell's parent: 
            if all_array(1).AreaShape_Zernike_7_1(cellcount_colony) == 0                
                cellparent = Parents(cellcount_colony).parent;
                
            % 8. parent's lifetime
                 correlation_calculated_properties(cellcount_all,8) = ...
                    Parents(cellparent).lifetime;
               
            % 9. parent's max size
                 correlation_calculated_properties(cellcount_all,9) = ...
                     max(Data(cellparent).area);
                
            % 10. parent's divide size
                 % use the divide_size_table for this one:
                 correlation_calculated_properties(cellcount_all,10) = ...
                 divide_size_table(cellparent,1);
             else
                 correlation_calculated_properties(cellcount_all,8) = 0;
                 correlation_calculated_properties(cellcount_all,9) = 0;
                 correlation_calculated_properties(cellcount_all,10) = 0;
             end

           
           % find the maximum number of neighbors from the neighbor_table
             [max_neighbor,max_neighbor_tmpt] =...
                max(neighbor_table(:,cellcount_colony));
           
            % 11. max # of neighbors over cell's lifetime
            correlation_calculated_properties(cellcount_all,11) = ...
                    max_neighbor;
           
            % 12. time point at max # of neighbors
            correlation_calculated_properties(cellcount_all,12) = ...
                    max_neighbor_tmpt;   
           
            % 13. average # of neighbors (# neighbors / time points 
            % analyzed)
            correlation_calculated_properties(cellcount_all,13) = ...
                    sum(neighbor_table(:,cellcount_colony))./length(Data(cellcount_colony).time);
            % 14. number of neighbors total during lifetime
            correlation_calculated_properties(cellcount_all,14) = ...
                    sum(neighbor_table(:,cellcount_colony));
   
    % birth time point-associated properties         
    for timecount1=1:timepts  %for each time point
    
    %if this is the first time point, then enter the properties for the 
    %starting cells:    
         if timecount1==1 
            if all_array(1).AreaShape_Area(cellcount_colony) ~=0 
              correlation_calculated_properties(cellcount_all,15) = 1;
              correlation_calculated_properties(cellcount_all,16) =...
                  neighbor_table(1,cellcount_colony);
            end
         end
    
    % for all but the first time point, fill out the properties of each
    % cell at the time of its birth:
         if timecount1 ~=1 
            % if the area was zero in the previous time point, but non-zero
            % in this time point:
            if all_array(timecount1-1).AreaShape_Area(cellcount_colony)==...
                    0 && all_array(timecount1).AreaShape_Area...
                    (cellcount_colony) ~=0
               %then fill out each property for that cell:
               correlation_calculated_properties(cellcount_all,15) = ...
                   timecount1;
               correlation_calculated_properties(cellcount_all,16) =...
                  neighbor_table(timecount1,cellcount_colony);
            end
         end
    end
    
            
            % use the centroiddistance_table to calculate the maximum and
            % average distance from the colony center
            
            [max_dist,max_dist_tmpt] =...
                max(centroiddistance_table(:,cellcount_colony));
            correlation_calculated_properties(cellcount_all,17) = max_dist;
            correlation_calculated_properties(cellcount_all,18) = ...
                    mean(nonzeros(centroiddistance_table(:,cellcount_colony)));
            
            %maximum, average, and max - min eccentricity:
            [max_eccentricity,max_eccentricity_tmpt] =...
                    max(eccentricity_table(:,cellcount_colony));
            correlation_calculated_properties(cellcount_all,19) = ...
                    max_eccentricity;
            correlation_calculated_properties(cellcount_all,20) = ...
                    mean(nonzeros(eccentricity_table(:,cellcount_colony)));
            correlation_calculated_properties(cellcount_all,21) = ...
                    max_eccentricity - ...
                    min(nonzeros(eccentricity_table(:,cellcount_colony)));    
                
            % average area
            correlation_calculated_properties(cellcount_all,22) = ...
                    mean(Data(cellcount_colony).area);
          
           % time points analyzed:
           correlation_calculated_properties(cellcount_all,23) = ...
               length(Data(cellcount_colony).time);
           
           % incorporating senescence info
           % assume all cells are dividing unless shown otherwise
           correlation_calculated_properties(cellcount_all,24) = 1;
           
         
           for senescence_colony_counter = 1:size(senescence_table_colony,1)
                if all_array(374).Number_Object_Number(1,cellcount_colony) == ...
                           senescence_table_colony(senescence_colony_counter,1)
                       correlation_calculated_properties(cellcount_all,24) = ...
                           senescence_table_colony(senescence_colony_counter,2);
                end
           end

            % incorporating # starting cells:
           correlation_calculated_properties(cellcount_all,25) = size(RealN(1).num,2);
         
           
           % asynchronicity and senescence
         
           % 26. (B) is asynchronous twin?  (1 = no, 2 = yes)
           % make a matrix of asynchronized twins for this colony only:
            colony_async_rows = find(async_table(:,5) == colony_number);
            colony_mat = async_table(colony_async_rows,1:2);  
            % if a twin is listed in that matrix as being asynchronous,
            % give a value of 2.  Otherwise, =1.
            if isempty(find(colony_mat == cellcount_colony)) == 1
            correlation_calculated_properties(cellcount_all,26) = 1;
            else
            correlation_calculated_properties(cellcount_all,26) = 2;   
            end

            % 27. (B) had asynchronous daughters? (1 = no, 2 = yes)

            %if this cell had children
            if isempty(Parents(cellcount_colony).children) == 0

            % if this cell's children show up in the async matrix, then the answer is 
            % yes.  Otherwise, it's no.
                if (isempty(find(colony_mat == Parents(cellcount_colony).children(1))) ||  isempty(find(colony_mat == Parents(cellcount_colony).children(2)))) == 0
                    correlation_calculated_properties(cellcount_all,27) = 2;
                else
                    correlation_calculated_properties(cellcount_all,27) = 1;
                end
                
            %otherwise, the cell didn't have children, and the answer is no:
            else
                    correlation_calculated_properties(cellcount_all,27) = 1;    
            end
            
            
            % 28. (B) had senescent daughters?  (1 = no, 2 = yes)
            
            % set default value to 1 to index all non-dividing cells
            correlation_calculated_properties(cellcount_all,28) = 1;
            
            % analyze only dividing cells
            if isempty(Parents(cellcount_colony).children) == 0

                % identify the children of this cell
                child1 = Parents(cellcount_colony).children(1);
                child2 = Parents(cellcount_colony).children(2);
                child1_object_number = all_array(374).Number_Object_Number(1,child1);
                child2_object_number = all_array(374).Number_Object_Number(1,child2);
                
                senescent_count = 0; % number of senescent daughters
                
                % if either child is senescent, answer is 2 (yes). 
                    if child1_object_number ~= 0 && ...
                            senescence_table_colony(child1_object_number,2) == 2 
                       correlation_calculated_properties(cellcount_all,28) = 2;
                       senescent_count = senescent_count + 1;
                    end
                    if child2_object_number ~=0 && ...
                            senescence_table_colony(child2_object_number,2) == 2 
                       correlation_calculated_properties(cellcount_all,28) = 2;
                       senescent_count = senescent_count + 1;
                    end
                 % 29. # senescent daughters (0, 1, 2)
                 correlation_calculated_properties(cellcount_all,29) = ...
                     senescent_count;
                 clear senescent_count
                    
            end

           % 30. progeny classification 
           % 1 = slow dividing progeny, 2 = mid, 3 = fast.
           % See classify_dividers.m for how to generate
           % the divider_table.  Calculations here are made using the
           % divider_array (constructed in colony prep section above)
           
           % start by assuming each cell is not near a slow divider (will
           % correct if necessary in the upcoming forloop)
           correlation_calculated_properties(cellcount_all,31) = 1;
           
           for progenycount = 1:size(divider_array,1)
               % identify which progeny this cell belongs to
               % if it's a starting cell, it belongs to its own progeny
               if cellcount_colony == progenycount
                   correlation_calculated_properties(cellcount_all,30) = divider_array{progenycount,2};
                            
               % otherwise, if the cell belongs to this progeny, fill out
               % the classifier column.  
               elseif isempty(find(divider_array{progenycount,3} == cellcount_colony))== 0
                  correlation_calculated_properties(cellcount_all,30) = divider_array{progenycount,2};
               end
               
               %31. (B) is in colony with slow divider?  (1 = no, 2 = yes)
           
               if isempty(find(divider_array{progenycount,2} == 1)) == 0
                correlation_calculated_properties(cellcount_all,31) = 2;
               end
               
               % if the cell doesn't belong to this progeny, move on to the
               % next progeny in this colony
           end
           
             % 32 (B) Is fast divider? (1 = no, 2 = yes)
            
             %assume no, correct if yes:
            correlation_calculated_properties(cellcount_all,32) = 1;
             
            if correlation_calculated_properties(cellcount_all,30) == 3
            correlation_calculated_properties(cellcount_all,32) = 2;
            end
         
            % 33, 34 max, avg distance from birth
            % use the birthdistance_table to calculate the maximum and
            % average distance from its place of birth
            
            [b_max_dist,b_max_dist_tmpt] =...
                max(birthdistance_table(:,cellcount_colony));
            correlation_calculated_properties(cellcount_all,33) = b_max_dist;
            correlation_calculated_properties(cellcount_all,34) = ...
                    mean(nonzeros(birthdistance_table(:,cellcount_colony)));
           
                %%%%%%establish the last column of the table:
            if colcount==1 && cellcount_colony==1
            colony_column = size(correlation_calculated_properties,2)+1;
            end
            %add colony number to very end:
            correlation_calculated_properties(cellcount_all,colony_column) = ...
                colony_number;
        
        end
        clear Data RealN Parents cellcount_colony divide_size_table...
            centroiddistance_table neighbor_table eccentricity_table...
            senescence_table_colony colony_async_rows colony_mat...
            divider_array
         
        
end

correlation_table = array2table(correlation_calculated_properties);

% give the variable columns headings        
correlation_table.Properties.VariableNames =...
    {'max_area'...
    'max_area_time_point'...
    'generation'...
    'lifetime'...
    'number_of_progeny'...
    'divide_size'...
    'total_distance_travelled'...
    'parent_lifetime'...
    'parent_max_size'...
    'parent_divide_size'...
    'max_number_of_neighbors'...
    'time_point_at_max_number_of_neighbors'...
    'average_number_of_neighbors'...
    'cumulative_number_of_neighbors'...
    'birth_time_point'...
    'number_of_neighbors_at_birth'...
    'max_distance_from_colony_centroid' ...
    'average_distance_from_colony_centroid'...
    'maximum_eccentricity' ...
    'average_eccentricity'...
    'max_minus_min_eccentricity'...
    'average_area'...
    'time_points_analyzed'...
    'senescence'...
    'num_start_cells'...
    'is_asynchronous'...
    'has_asynchronous_daughters'...
    'has_senescent_daughters'...
    'num_senescent_daughters'...
    'divider_classification'...
    'is_near_slow_divider'...
    'is_fast_divider'...
    'max_dist_birth'...
    'avg_dist_birth'...
    'colony_number'};
  
cd(save_path)
% Save the property names for downstream analysis:
property_names = correlation_table.Properties.VariableNames;
property_names = property_names';
property_names = cell2table(property_names);
writetable(property_names, [fullfile(save_path), save_name '_property_names.csv'], 'WriteVariableNames',false);
% Save the table for this colony
writetable(correlation_table,[fullfile(save_path), save_name '.csv'], 'WriteVariableNames',false);

if make_table_headers == 1
writetable(correlation_table,[fullfile(save_path), save_name '_with_names.csv'], 'WriteVariableNames',true);
end
