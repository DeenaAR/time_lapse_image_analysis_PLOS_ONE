%% D17
%%%%%%%%%%%%%%%%%%%%%%% description %%%%%%%%%%%%%%%
% This analysis finds all the cells whose time point at division differs 
% from its twin cell by a specified amount.  It creates a table
% (async_table) cataloging the unique number of each twin cell, the number
% of time points their divisions differ by, their generation, and the
% colony they belong to.  
%
% The table contains this information for all colonies that have 
% CellProfiler output files in a specified folder.  See inputs below.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%%%%%%%%%%%%%%%%% inputs %%%%%%%%%%%%%%%%%%%%%%%%%

%set the threshold for how far apart tiwns have to divide to be considered
%not in sync (in time points).  Currently this is set to the standard
%deviation of lifetimes of all cells in single-cell-derived colonies.  An
%option to use the geometric mean/deviation instead of the standard
%deviation is below.
standard_division_cutoff = 25;  

%path to the CellProfiler output files:
data_path=('C:\');
%flag as 1 to save the ansync matrix as a table:
save_table = 1;
    
    %if saving is flagged:
    %path to save table to (ignore if saving not flagged)::
    save_path=('C:\');
    % what to name the table (ignore if saving not flagged):
    date_stamp = '1-4-17';

% flag to use the geometric mean for calculating asynchronicity (instead of
% the standard deviation)
use_geometric = 0;
    
    %if use_geometric is flagged, set the geometric deviation.  Currently
    %this is set to the geometric deviation of lifetimes of all cells in
    %single-cell-derived colonies.
    geometric_deviation = 1.123851611;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 
%%%%%%%%%%%%%%%% execution %%%%%%%%%%%%%%%%%%%%%%%%

% setup the matrix containing ansynchronous twins:
async_mat = [];
async_tick = 1;

% specify the output files
Files = dir(fullfile(data_path, '*.mat'));

for colcount = 1:length(Files)
    
    % Identify the colony name for labeling later:
    FileName = Files(colcount).name; 
    colony_name_start = strfind(FileName,'T4')+7;
    colony_name_end = strfind(FileName,'.mat')-1;
    colony_underscore_name = cellstr(FileName(1:colony_name_end));
    colony_name = strrep(colony_underscore_name, '_', ' ')
    colony_number = str2double(FileName([2 3 5 6])); 
    
    % open the CellProfiler output file 
    load(fullfile(data_path, FileName));
    
    % Runs a crappy version of cell_tracking_figures.m meant not to plot/save
    % any figures.  Requires getdata6.m:
    cell_tracking_figures_for_other_analyses

   

    % Make new columns in the Parents structure (generated by the 
    % cell_tracking_figures code).  pseudosplit is used when finding
    % asynchronous twins implementing the standard deviation, and
    % pseudolifetime is used when implementing the geometric deviation.  In
    % both cases, cells that never divide are not considered unless its
    % twin divided (in which case the cell is set to have divided at the
    % final time point, hence the "pseudo").
    Parents(1).pseudosplit = []; 
    Parents(1).pseudolifetime = [];

    % Add the division time points to the pseudosplit column:
    clear cellcounter
    for cellcounter = 1:size(Parents,2)   
            Parents(cellcounter).pseudosplit = Parents(cellcounter).split;   
    end


    % Need to account for cells that never divide and their
    % twin does.  If this happens, the non-dividing twin is marked as
    % dividing at the final time point.  Note that if neither twin 
    % divides, the value is left blank.
    clear cellcounter
    for cellcounter = 1:size(Parents,2)
        if Parents(cellcounter).gen ~= 1 
            if isempty(Parents(Parents(cellcounter).twin).pseudosplit)== 1 && ...
                    isempty(Parents(cellcounter).pseudosplit) == 0
                Parents(Parents(cellcounter).twin).pseudosplit = timepts;     
             end
        end
    end
    
   % fill in the pseudolifetime column
   clear cellcounter
   for cellcounter = 1:size(Parents,2)
    
     % set first-gen cells as being born at time point zero.  First-gen 
     % cells are never considered in the analysis - this is purely for
     % filling out the pseudolifetime column.
     if isempty(Parents(cellcounter).born) == 1
            Parents(cellcounter).born = 0;
     end
     
     %Fill out pseudolifetime column; if the cell doesn't have a
     %pseudosplit value then the lifetime is set to 0.  This means cells
     %that never divided are not considered unless its twin divided.
     if isempty(Parents(cellcounter).pseudosplit) ~=1
        Parents(cellcounter).pseudolifetime = ...
            Parents(cellcounter).pseudosplit - Parents(cellcounter).born;
     else
        Parents(cellcounter).pseudolifetime = 0;
     end
        
  end
        

    % Find the twins that divide at time points farther apart than the
    % overall standard deviation:
    clear cellcounter
    for cellcounter = 1:size(Parents,2) %for each cell that ever existed
        if use_geometric ~= 1
            %exclude 1st generation cells, which don't have twins:
            if Parents(cellcounter).gen ~= 1
                %if the difference between the twins' division time points is off
                %by more than division_cutoff, index them in the async_table.
                if Parents(cellcounter).pseudosplit -...
                        Parents(Parents(cellcounter).twin).pseudosplit > standard_division_cutoff
                    async_mat(async_tick,1) = cellcounter;
                    async_mat(async_tick,2) = Parents(cellcounter).twin;
                    async_mat(async_tick,3) = Parents(cellcounter).pseudosplit -...
                        Parents(Parents(cellcounter).twin).pseudosplit;
                    async_mat(async_tick,4) = Parents(cellcounter).gen;
                    async_mat(async_tick,5) = colony_number;
                    
                    async_tick = async_tick + 1;
                end
            end
        end
        
        if use_geometric == 1
            if Parents(cellcounter).gen ~= 1
                %if the difference between the twins' division time points is off
                %by more than division_cutoff, index them in the async_table.
                if Parents(cellcounter).pseudolifetime/Parents(Parents(cellcounter).twin).pseudolifetime > geometric_deviation
                    async_mat(async_tick,1) = cellcounter;
                    async_mat(async_tick,2) = Parents(cellcounter).twin;
                    async_mat(async_tick,3) = Parents(cellcounter).pseudolifetime/Parents(Parents(cellcounter).twin).pseudolifetime;
                    async_mat(async_tick,4) = Parents(cellcounter).gen;
                    async_mat(async_tick,5) = colony_number;
                    
                    async_tick = async_tick + 1;
                end
            end
        end
            
    end
end

 %convert to a table and name the columns:
 async_table = array2table(async_mat);
 if use_geometric ~=1
 async_table.Properties.VariableNames = {'Twin_1' 'Twin_2' ...
     'Split_Time_Difference' 'Generation' 'Colony'};

 % Save the table as a csv (with and without column headers)
    if save_table == 1   
    writetable(async_table,[fullfile(save_path), date_stamp '_asynchronous_twins_no_headers_standard.csv'], 'WriteVariableNames',false);
    writetable(async_table,[fullfile(save_path), date_stamp '_asynchronous_twins_standard.csv'], 'WriteVariableNames',true);
    end

else
      async_table.Properties.VariableNames = {'Twin_1' 'Twin_2' ...
     'Geometric_Deviation' 'Generation' 'Colony'};

 % Save the table as a csv (with and without column headers)
    if save_table == 1   
    writetable(async_table,[fullfile(save_path), date_stamp '_asynchronous_twins_no_headers_geometric.csv'], 'WriteVariableNames',false);
    writetable(async_table,[fullfile(save_path), date_stamp '_asynchronous_twins_geometric.csv'], 'WriteVariableNames',true);
    end
end
