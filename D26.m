%% D26 based off of code by Matt Whitfield and modified by Deena Rennerfeldt
%% Clear important variables

clear Parents RealN Data numcell genN twin1 twin2 touching touchnum...
    genlist genname parentgrid labelgrid areagrid xlocgrid ylocgrid ...
    numcells neighbors orderstarters
%% Set things up
%specify the colony name (e.g., 'Laughing Shadow (T43C70)' and figure path


cd 'C:\';
Files = dir('*.mat');
for colcount = 1:size(Files,1)
   async_table = csvread('C:\asynchronous_twins.csv');
   
   
   
   
    FileName = Files(colcount).name; 
    % go through the file names in the 1st_time_point folder to determine
    % the colony names
    colony_name_start = strfind(FileName,'T4')+7;
    colony_name_end = strfind(FileName,'.mat')-1;
    colony_underscore_name = cellstr(FileName(1:colony_name_end));
    colony_name = strrep(colony_underscore_name, '_', ' ');
    colony_number = str2double(FileName([2 3 5 6])); 
    
    % make matrix of THIS COLONY with twin 1 and
                              % twin 2 called colony_mat
    colony_async_rows = find(async_table(:,5) == colony_number);
    colony_mat = async_table(colony_async_rows,1:2); 
    
    load(FileName);
path_to_save = 'C:\Users\Deena\Desktop\code_test_temp';


% "Flag" each variable (by setting it's value equal to 1 instaed of 0)
% corresponding to the analyses to be made (see comments for each
% variable).
savefigures=1;      % Flag if you want to save the figures to figurepath.

moviemade = 0;      % Flag to make a movie of original (or masked) images 
                    % overlayed with images of cells colored for 
                    % generation.  path1, path2, and savepath must be 
                    % specified.  These terms are searchable.

twinanalysis=1;     % Flag to do the "twin analysis" that categorizes twins
                    % based on whether or not they divided

dotouch=1;          % Flag if cell-cell contacts have been measured in 
                    % CellProfiler (via the MeasureObjectNeighbors module).
                    
grid=1;             % Number of grids being analyzed at a time (just one 
                    % for Project 4).

dopre=0;            % Flag if analyzing the previous presence of cells. 
                    % This requires the ConvertObjectsToImage module as
                    % well as saving the masked images as mat files.
                    
doplot=1;           % Flag to generate figures

docurr=0;           % Unsure what this does.  
                    % Matt's comment: 1 if detailed current contact runclosea

umperpx=.639;       % microns per pixel - determines cell area and depends 
                    % on the resolution of the images
                    
timepointfix=96;    % conversion factor from # of time points to days.  If 
                    % time points are 15 minutes apart, set this to 96 
                    % (i.e., there are 96 15-minute time points in a day)
                    
threshsml=8000;     % Spread area threshold for considering a cell small

lifetimecutoff=1.5;  % Lifetime of a cell to be considered senescent (for 
                    % twin analysis).

% mintimepoint=50;     % the minimum number of time points a cell has to exi
%                     % to be considered in the twin analyses

% Call function to extract data from input CellProfiler outputs
[parentgrid,labelgrid,areagrid,xlocgrid,ylocgrid,numcells,neighbors,...
    eccentricity,integrateddistance,formfactor]=getdata6(handles,dotouch,...
    grid);
% The outputs generated by this function (getdata)are arrays.  See getdata
% for information on how those data are arranged by CellProfiler.  The 
% array outputs are each described below:

% parentgrid:  A "parent object" is the object in the preceeding image that
%              overlaps with the current object (i.e. it's the object/cell 
%              in the previous time point).  A "parent object number" is
%              the label assigned to the parent object.  parentgrid is an
%              array of the parent object numbers for each object at each 
%              time point
%             
% labelgrid:   An array of label numbers for each object at each time point             
%
% areagrid:    An array of the area of each object (in px) at each time
%              point
% xlocgrid, ylocgrid:   x- and y-coordinates of the center of each object
%                       at each time point
% 
% numcells:    the number of cells at each time point
% 
% neighbors:   neighbors is an array constructed in getdata6.m.  The array
%              has two columns: t and n.  t measures percent touching; n
%              measures number of neighbors (for each object at each time 
%              time point).  It is set up to calculate these two variables
%              for a threshold distance of 5, 10, 15, and 20 pixels.  
%              Example: neighbors(3).n is an array containing the number of
%              neighbors each object has at each time point when a distance
%              of 15 pixels was considered for an object to be a neighbor.


timepts=length(parentgrid);         % # of time points
rtime=(1:timepts)./timepointfix;    % For graphing purposes


% If you want to calculate cells interaction with the previous presence of cells at each location
if dopre==1
    totalcontact(1:timepts)= struct('a',[]);
    totalpxls(1:timepts)=  struct('a',[]);
    path3='L:\Subproject_4-2\Complete_colonies\T45C70_Laughing_Shadow\tracked_FINAL\IDs';
    [totalcontact,totalpxls]=calcprevcontact(path3,2,RealN,totalcontact,totalpxls);
end

% Scale the inputs
for i=1:timepts
    areagrid{i}=double(areagrid{i});
    for j=1:length(areagrid{i})
        if areagrid{i}(j)~=-1
            areagrid{i}(j)=areagrid{i}(j)*umperpx^2;
            xlocgrid{i}(j)=xlocgrid{i}(j)*umperpx;
            ylocgrid{i}(j)=ylocgrid{i}(j)*umperpx;
            integrateddistance{i}(j)=integrateddistance{i}(j)*umperpx;
        end
    end
end

cells=length(parentgrid{1,1});      % total number of tracked cells (split cells and new cells)
if length(parentgrid{1,1})>1000
    cells2=sum(parentgrid{1,1}(1:1000)~=-1);
    cells1=sum(parentgrid{1,1}(1001:end)~=-1)+1000;
    startcells1=cells1;
else
    cells2=cells;
    cells1=0;
    startcells1=0;
end
startcells2=cells2;
startercells=labelgrid{1,1}(find(labelgrid{1,1}~=-1)); % # of cells at start of experiment 


% Initialize data storage structures
Parents(1:cells)= struct('ancestor',[],'parent',[],'leave',[],'split',[],'children',[],'twin',[],'lineage',[],'lineagetime',[],'born',[],'appear',[],'gen',1,'lifetime',0,'descend',-1,'splitsize',0);
for o=1:length(labelgrid{1,1})
    Parents(o).ancestor=labelgrid{1,1}(o);        % parent # of cells at start
end
Data(1:cells)= struct('num',[],'label',[],'gen',[],'time',[],'area',[],'small',0,'xloc',[],'yloc',[],'prec',[],'pren',[],'eccentricity',[],'formfactor',[],'migrate',[],'totaldist',[]);

RealN(1:timepts)=struct('num',[],'label',[],'parent',0,'gen',0,'area',0,'xloc',[],'yloc',[],'prec',[],'pren',[],'eccentricity',[],'formfactor',[],'totaldist',[],'distcentroid',[]);
RealN(1).num=(1:cells)*0;
RealN(1).label=(1:cells)*0;
RealN(1).parent=(1:cells)*0;
RealN(1).gen=(1:cells)*0;
RealN(1).area=(1:cells)*0;
RealN(1).xloc=(1:cells)*0;
RealN(1).yloc=(1:cells)*0;
RealN(1).eccentricity=(1:cells)*0;
RealN(1).formfactor=(1:cells)*0;
RealN(1).totaldist=(1:cells)*0;
RealN(1).distcentroid=(1:cells)*0;
if dopre==1
    RealN(1).prec=(1:cells)*0;
    RealN(1).pren=(1:cells)*0;
end
if dotouch==1
    for np=3
        RealN(1).touch(np).t=(1:cells)*0;
        RealN(1).touch(np).n=(1:cells)*0;
    end
end

%% Convert the raw input data into synthesized metrics
for t=1:timepts % total number of timesteps
    for c=1:length(parentgrid{1,t})         % number of cells at that timestep
        if parentgrid{1,t}(c)~=-1
            cellN=labelgrid{1,t}(c);        % Cell number (split cells keep parent #)
            parentN=parentgrid{1,t}(c);     % # of cell in previous timestep 
            cellA=areagrid{1,t}(c);         % Cell area
            xloc=xlocgrid{1,t}(c);          % X position of center of mass
            yloc=ylocgrid{1,t}(c);          % Y position of center of mass
            eccen=eccentricity{1,t}(c);
            formfact=formfactor{1,t}(c);
            totaldist=integrateddistance{1,t}(c);
            if c<1000
                cells=cells2;
            else
                cells=cells1;
            end

            if dotouch==1
                for np=1:4
                    touching(np).a=neighbors(np).t{1,t}(c);
                    touchingnum(np).a=neighbors(np).n{1,t}(c);
                end
            end
            cellI=c;
            indexC=find(labelgrid{1,t}==cellN);      % twin cells
            indexP=find(parentgrid{1,t}==parentN);   % if two then split this time

            % uniqueN - unique number assigned to daughter cells when cells split
            if t~=1
                uniqueN=RealN(t-1).num(find(RealN(t-1).label==cellN & RealN(t-1).parent==parentN));
                gen=RealN(t-1).gen(find(RealN(t-1).label==cellN & RealN(t-1).parent==parentN));
            else
                uniqueN=cellN;
                gen=1;
            end

            if length(indexP)>1 && t~=1 && (parentN~=0) % if split this timestep
                cells=cells+1;
                Parents(uniqueN).split=t;               % time that cell split
                Parents(uniqueN).children=horzcat(Parents(uniqueN).children,cells);     % Unique id# of child cells 
                Parents(cells).parent=uniqueN;     % Unique id# of child cells 
                if cellN<=startcells2 || (cellN>1000 && cellN<=startcells1)
                    Parents(cellN).lineage=horzcat(Parents(cellN).lineage,cells);       % Unique id# of all cells that parent cell at start of experiment gives rise to
                    Parents(cellN).lineagetime=horzcat(Parents(cellN).lineagetime,t);       % Time of splits
                end
                uniqueN=cells;                          % Assigns unique number to child cell
                Parents(uniqueN).born=t;                % time daughter cell is "born"
                gen=gen+1; 
                Parents(uniqueN).gen=gen;               % generation of daughter cell
                Parents(uniqueN).ancestor=cellN;          % original parent #
            elseif (parentN==0) && t~=1                   % when a new cell appears (not from division)
                cells=cells+1;
                uniqueN=cells;
                gen=1;
                Parents(uniqueN).gen=gen;               % generation of daughter cell
                %Parents(uniqueN).ancestor=cellN;          % original parent #
                Parents(uniqueN).appear=t;
            end
            if dopre==1
                prec=totalcontact(1,t).a(uniqueN);      % total number of previous cell contact under cell
                pren=totalpxls(1,t).a(uniqueN);         % number of pixels under cell
            end
            RealN(t).num(uniqueN)=uniqueN;
            RealN(t).label(uniqueN)=cellN;
            RealN(t).parent(uniqueN)=cellI;  
            RealN(t).gen(uniqueN)=gen; 
            RealN(t).area(uniqueN)=cellA;
            RealN(t).xloc(uniqueN)=xloc;
            RealN(t).yloc(uniqueN)=yloc;
            RealN(t).eccentricity(uniqueN)=eccen;
            RealN(t).formfactor(uniqueN)=formfact;
            RealN(t).totaldist(uniqueN)=totaldist;
            if dopre==1
                RealN(t).prec(uniqueN)=prec;
                RealN(t).pren(uniqueN)=pren;
            end
            if dotouch==1
                for np=1:4
                    RealN(t).touch(np).t(uniqueN)=touching(np).a;
                    RealN(t).touch(np).n(uniqueN)=touchingnum(np).a;
                end
            end
            if c<1000
                cells2=cells;
            else
                cells1=cells;
            end
        end
    end
end
%%%%% Find the centroid of a colony at each time point

centroid = zeros(timepts,2);
for i = 1:timepts
    %cell coordinates:
    XValues=(handles.Measurements.RelabeledCells.Location_Center_X{1,i})*umperpx;
    YValues=(handles.Measurements.RelabeledCells.Location_Center_Y{1,i})*umperpx;
    
    if length(XValues) == 1 %if there is only one cell
        XCoord = XValues;
        YCoord = YValues;
    else
        XCoord=mean(XValues);
        YCoord=mean(YValues);
    end
    centroid(i,1) = XCoord; 
    centroid(i,2) = YCoord;
end
%%%%% Put the distance from centroid for each cell into RealN:

for i = 1:timepts %for each time point
    for j = 1:length(RealN(i).num) %for each cell at a time point
        if RealN(i).num(j)~=0
        RealN(i).distcentroid(j) = sqrt((RealN(i).xloc(j) - centroid(i,1))^2 + (RealN(i).yloc(j) - centroid(i,2))^2);
        else
        RealN(i).distcentroid(j)=0;
        end
    end 
end

% Determine lineage of cells that split after start of experiment
for c=startcells2+1:cells
    if c<=cells2 || c>startcells1
        child1=c;
        child2=c;
        i=1;
        while isempty(Parents(child1).children)==0
            child2=Parents(child1).children(2);
            child1=Parents(child1).children(1);
            Parents(c).lineage=horzcat(Parents(c).lineage,child1,child2);
    %         Parents(c).lineagetime=horzcat(Parents(c).lineagetime,t,t);
            while isempty(Parents(child2).children)==0
                child1=Parents(child2).children(1);
                child2=Parents(child2).children(2);
                Parents(c).lineage=horzcat(Parents(c).lineage,child1,child2);
            end
        end
    end
end

% Determine twins from cells existing in first image
for i=1:startcells2
    for ii=1:2:length(Parents(i).lineage)
        Parents(Parents(i).lineage(ii)).twin=Parents(i).lineage(ii+1);
        Parents(Parents(i).lineage(ii+1)).twin=Parents(i).lineage(ii);
    end
end

% Determine twins from cells existing in first image
if c>1000
    for i=1001:startcells1
        for ii=1:2:length(Parents(i).lineage)
            Parents(Parents(i).lineage(ii)).twin=Parents(i).lineage(ii+1);
            Parents(Parents(i).lineage(ii+1)).twin=Parents(i).lineage(ii);
        end
    end
end

for i=1:cells
    if c<=cells2 || c>startcells1
        % These only produce output for cells that have split and been born
        Parents(i).lifetime=Parents(i).split-Parents(i).born;
        if isempty(Parents(i).lifetime)==1
            Parents(i).lifetime=0;
        end
        Parents(i).descend=length(Parents(i).lineage);

        % Find out avg cell size 8-4 timepoints before split
        if Parents(i).split>0
            if isempty(Parents(i).appear)==0
                if (Parents(i).split-Parents(i).appear)>8
                    Parents(i).splitsize=mean([RealN(Parents(i).split-4).area(i),RealN(Parents(i).split-5).area(i),RealN(Parents(i).split-6).area(i),RealN(Parents(i).split-7).area(i),RealN(Parents(i).split-8).area(i)]);
                end
            else
                if (Parents(i).split-Parents(i).born)>8
                    Parents(i).splitsize=mean([RealN(Parents(i).split-4).area(i),RealN(Parents(i).split-5).area(i),RealN(Parents(i).split-6).area(i),RealN(Parents(i).split-7).area(i),RealN(Parents(i).split-8).area(i)]);
                end
            end
        end
        if isempty(Parents(i).splitsize)==1
            Parents(i).splitsize=0;
        end

        % To convert data to matrix form for plotting
        counter=0;
        for j=1:timepts
            if i<=RealN(j).num(end)
                if RealN(j).num(i)~=0
                    counter=counter+1;
                    Data(i).num=RealN(j).num(i);
                    Data(i).label=RealN(j).label(i);
                    Data(i).gen=RealN(j).gen(i);
                    Data(i).time(counter)=j;
                    Data(i).area(counter)=RealN(j).area(i);
                    Data(i).xloc(counter)=RealN(j).xloc(i);
                    Data(i).yloc(counter)=RealN(j).yloc(i);
                    Data(i).eccentricity(counter)=RealN(j).eccentricity(i);
                    Data(i).formfactor(counter)=RealN(j).formfactor(i);
                    Data(i).totaldist(counter)=RealN(j).totaldist(i);
                    Data(i).distcentroid(counter)=RealN(j).distcentroid(i);
                    if counter>1
                        Data(i).migrate(counter)=sqrt((Data(i).xloc(counter)-Data(i).xloc(counter-1))^2+(Data(i).yloc(counter)-Data(i).yloc(counter-1))^2)*2;
                    else
                        Data(i).migrate(counter)=0;
                    end
                    if dopre==1
                        Data(i).prec(counter)=RealN(j).prec(i);
                        Data(i).pren(counter)=RealN(j).pren(i);
                    end
                    if dotouch==1
                        for np=1:4
                            Data(i).touch(np).t(counter)=RealN(j).touch(np).t(i);
                            Data(i).touch(np).n(counter)=RealN(j).touch(np).n(i);
                        end
                    end
                end
            end
        end
    end
    Data(i).totaldist= Data(i).totaldist-Data(i).totaldist(1);
end

% find cells that disappear but dont divide
for i=1:length(RealN(timepts).num)
    if isempty(Data(i).time)==0
        if isempty(Parents(i).split)==1 && Data(i).time(end)~=timepts
            Parents(i).leave=Data(i).time(end)+1;
        end
    end
end

numcell=(1:timepts)*0;
areacell=(1:timepts)*0;
areacellsem=(1:timepts)*0;
smallcell=zeros(length(threshsml),timepts);
largecell=zeros(length(threshsml),timepts);
for o=1:timepts
    numcell(o)=numcells(o);         % total # of cells over time
    areacell(o)=mean(RealN(o).area(RealN(o).area~=0));
    areacellsem(o)=std(RealN(o).area(RealN(o).area~=0))/sqrt(length(RealN(o).area(RealN(o).area~=0)));
    for p=1:length(threshsml)
        smallcell(p,o)=sum(areagrid{o}<=threshsml(p) & areagrid{o}>0);
        largecell(p,o)=sum(areagrid{o}>threshsml(p));
    end
end


genlist=[];
lifetime=[];
dividesize=[];
% descend=[];
descend(1:cells)=(1:cells)*0-1;
genname=[];
for i=1:cells
    if Parents(i).lifetime>0 && (Parents(i).ancestor<=startcells2 )%|| (Parents(i).ancestor<=startcells1 &&  Parents(i).ancestor>1000))
        lifetime=vertcat(lifetime,Parents(i).lifetime);
        dividesize=vertcat(dividesize,Parents(i).splitsize);
        genlist=vertcat(genlist,Parents(i).gen);
        genname=vertcat(genname,Data(i).num);
%         descend=vertcat(descend,Parents(i).descend);
    end
    descend(i)=Parents(i).descend;
end

% Statistics within each generation of cells
genN(1:timepts)=struct('A',[],'N',[],'Std',[],'CSb',[],'CSl',[]);
for o=1:max(genlist)+1
    CSb=0;
    CSl=0;
    for i=1:timepts
        genN(o).A(i)=mean(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        genN(o).N(i)=length(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        genN(o).Std(i)=std(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        for j=1:length(Parents)
            if Parents(j).born==i 
                if Parents(j).gen==o & (Parents(j).ancestor<=startcells2 | (Parents(j).ancestor<=startcells1 &  Parents(j).ancestor>1000))
                    CSb=CSb+1;
                end
            end
            if Parents(j).leave==i 
                if Parents(j).gen==o & ((Parents(j).ancestor<=startcells2 & Parents(j).ancestor>0) | (Parents(j).ancestor<=startcells1 &  Parents(j).ancestor>1000))
                   CSl=CSl+1;
                end
            end
        end 
        genN(o).CSb(i)=CSb;
        genN(o).CSl(i)=CSl;
    end
end

% Cumulative sum
cumm(1:max(genlist))=struct('a',[],'b',[],'c',[],'d',[]);
for j=2:max(genlist)+1
    for i=1:length(Parents)
        if Parents(i).gen==j && (Parents(i).ancestor<=startcells2 || (Parents(i).ancestor<=startcells1 &&  Parents(i).ancestor>1000))
            cumm(j-1).a=horzcat(cumm(j-1).a,Parents(i).born);
            if isempty(Parents(i).leave)~=1
                cumm(j-1).c=horzcat(cumm(j-1).c,Parents(i).leave);
            end
        end
    end
    cumm(j-1).a=sort(cumm(j-1).a);
    cumm(j-1).b=horzcat(0,1:length(cumm(j-1).a),length(cumm(j-1).a));
    cumm(j-1).a=horzcat(0,cumm(j-1).a,timepts)/timepointfix;
    
    cumm(j-1).c=sort(cumm(j-1).c);
    cumm(j-1).d=horzcat(0,1:length(cumm(j-1).c),length(cumm(j-1).c));
    cumm(j-1).c=horzcat(0,cumm(j-1).c,timepts)/timepointfix;
end

%%% TWIN INFO
firsttwin=1;
count=1;
for i=startcells2+1:cells
    if isempty(Parents(i).twin)==0 && firsttwin~=Parents(i).twin
        twin1.N(count)=i;                           % Cell number
        twin1.P(count)=Parents(i).descend;          % Number of progeny    
        twin1.MA(count)=mean(Data(i).area);         % Cell area
        twin1.LT(count)=Parents(i).lifetime/timepointfix;     % Cell lifetime (only has a value if cell divides)                      % 
        if twin1.LT(count)>0
            twin1.TTD(count)=twin1.LT(count);       % time to depart (TTD)
        elseif isempty(Parents(i).leave)==0         % Cell leaves
            twin1.TTD(count)=(Parents(i).leave-Parents(i).born)/timepointfix;
        else
            twin1.TTD(count)=(timepts-Parents(i).born)/timepointfix;
        end

        twin1.G(count)=Parents(i).gen;
        if dotouch==1
            for np=1:4
                twin1.C(np).t(count)=mean(Data(i).touch(np).t);
                twin1.C(np).n(count)=mean(Data(i).touch(np).n);
            end
        end
        twin2.N(count)=Parents(i).twin;
        twin2.P(count)=Parents(Parents(i).twin).descend;
        twin2.MA(count)=mean(Data(Parents(i).twin).area);
        twin2.LT(count)=Parents(Parents(i).twin).lifetime/timepointfix;
        if twin2.LT(count)>0
            twin2.TTD(count)=twin2.LT(count);
        elseif isempty(Parents(Parents(i).twin).leave)==0
            twin2.TTD(count)=(Parents(Parents(i).twin).leave-Parents(Parents(i).twin).born)/timepointfix;
        else
            twin2.TTD(count)=(timepts-Parents(Parents(i).twin).born)/timepointfix;
        end

        twin2.G(count)=Parents(Parents(i).twin).gen;  
        if dotouch==1
            for np=1:4
                twin2.C(np).t(count)=mean(Data(Parents(i).twin).touch(np).t);
                twin2.C(np).n(count)=mean(Data(Parents(i).twin).touch(np).n);
            end
        end
        firsttwin=i;

          % Change order so that twin 1 always is one with most contacts
            if twin2.LT(count)>=twin1.LT(count)
%                 if twin2.C(count)*twin2.LT(count)>=twin1.C(count)*twin1.LT(count)
                store(1)=twin1.N(count);
                store(2)=twin1.P(count);           
                store(3)=twin1.MA(count);
                store(4)=twin1.LT(count);
                store(5)=twin1.TTD(count);
                store(6)=twin1.G(count);
                if dotouch==1
                    for np=1:4
                        store(2*np+5)=twin1.C(np).t(count);
                        store(2*np+6)=twin1.C(np).n(count);
                    end
                end
                twin1.N(count)=twin2.N(count);
                twin1.P(count)=twin2.P(count);           
                twin1.MA(count)=twin2.MA(count);
                twin1.LT(count)=twin2.LT(count);
                twin1.TTD(count)=twin2.TTD(count);
                twin1.G(count)=twin2.G(count); 
                if dotouch==1
                    for np=1:4
                        twin1.C(np).t(count)=twin2.C(np).t(count); 
                        twin1.C(np).n(count)=twin2.C(np).n(count);
                    end
                end
                twin2.N(count)=store(1);
                twin2.P(count)=store(2);           
                twin2.MA(count)=store(3);
                twin2.LT(count)=store(4);
                twin2.TTD(count)=store(5);
                twin2.G(count)=store(6);
                if dotouch==1
                    for np=1:4
                        twin2.C(np).t(count)=store(2*np+5);
                        twin2.C(np).n(count)=store(2*np+6);
                    end
                end
            end
            count=count+1;
    end    
end

% Group twin cells
EqualDiv=[]; EqualNoDiv=[]; UnEqualDiv1=[]; UnEqualDiv2=[]; EqualDivp=[]; EqualNoDivp=[]; UnEqualDivp=[]; EqualDivpp=[]; EqualNoDivpp=[]; UnEqualDivpp=[];
for i=1:length(twin1.LT)
    if twin1.TTD(i)>=lifetimecutoff && twin2.TTD(i)>=lifetimecutoff                                             % Cells that both do not divide within lifetimecutoff days
        EqualNoDiv=horzcat(EqualNoDiv,[twin1.N(i) twin2.N(i)]);
        EqualNoDivp=horzcat(EqualNoDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            EqualNoDivpp=horzcat(EqualNoDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    elseif twin1.TTD(i)<lifetimecutoff && twin2.TTD(i)<lifetimecutoff && twin1.LT(i)>0 && twin2.LT(i)>0       % Cells that both do divide within lifetimecutoff days
        EqualDiv=horzcat(EqualDiv,[twin1.N(i) twin2.N(i)]);
        EqualDivp=horzcat(EqualDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            EqualDivpp=horzcat(EqualDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    elseif (twin1.TTD(i)>=lifetimecutoff && twin2.TTD(i)<lifetimecutoff) && twin2.LT(i)>0                      % One cell divides within lifetimecutoff days, one does not
        UnEqualDiv1=horzcat(UnEqualDiv1,twin1.N(i));                                % Slow dividing cell
        UnEqualDiv2=horzcat(UnEqualDiv2,twin2.N(i));                                % Fast dividing cell
        UnEqualDivp=horzcat(UnEqualDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            UnEqualDivpp=horzcat(UnEqualDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    elseif (twin1.TTD(i)<lifetimecutoff && twin2.TTD(i)>=lifetimecutoff) && twin1.LT(i)>0                      % The other cell divides within two days, one does not
        UnEqualDiv1=horzcat(UnEqualDiv1,twin2.N(i));
        UnEqualDiv2=horzcat(UnEqualDiv2,twin1.N(i));
        UnEqualDivp=horzcat(UnEqualDivp,Parents(twin1.N(i)).parent);
        if isempty(Parents(Parents(twin1.N(i)).parent).parent)==0 && Parents(Parents(Parents(twin1.N(i)).parent).parent).split>0
            UnEqualDivpp=horzcat(UnEqualDivpp,Parents(Parents(twin1.N(i)).parent).parent);
        end
    end
end
EqualDiv=sort(EqualDiv);
EqualNoDiv=sort(EqualNoDiv);
UnEqualDiv1=sort(UnEqualDiv1);
UnEqualDiv2=sort(UnEqualDiv2);


%% Plot things
if doplot==1
    % Set up the color scheme for the plots
    splitC={[1 0.396 0.435],[0.996 0.584 0.360],[1 0.898 0.415],[0.627 0.862 0.384],[0.286 0.803 0.956],[0.188 0.435 0.819],[0.631 0.607 0.858]};
    splitC2={[1 0.396 0.435],[0.996 0.584 0.360],[1 0.898 0.415],[0.627 0.862 0.384],[0.286 0.803 0.956],[0.188 0.435 0.819],[0.631 0.607 0.858]}; % color code    % Plot area over time for cells
    generationlist={'1st','2nd','3rd','4th','5th','6th','7th','8th','9th','10th','11th','12th','13th','14th','15th','16th','17th','18th','19th','20th'};
    

%%%%% Average area of each generation over time 
        offset=zeros(1,max(genlist)+1); % Use offset if want to normalize to when each generation starts. This needs to be set by hand.
        legendentry=[];
    
%%%% Only run this section if a division has occurred
   
 
%%%%% Plot the lineage trees
        % j=1 - no slope
        % j=2 - slope related to total distance cell traveled
        % j=3 - slope related to cell formfactor
        % j=4 - slope related to cell eccentricity
        % j=5 - slope related to distance to center of colony
        figtitle={'No Slope','Total Distance Traveled','Form Factor','Eccentricity','Distance from Center'};
        for j=1%:5
              place=0;
%             dontplace=[137,138,139,140,151,152,153,154,165,166,167,168,180, 181, 182]; % If want to exclude any cells
            for k=1:length(startercells)
                parcell=startercells(k);
                figure('Color', [1 1 1],'name',[char(figtitle{j}) '_Starting Cell ' num2str(k)],'Position',[100,100,1500,1500])
                set(gca,'FontSize',16, 'linewidth', 2,'YTick', []);
                title(colony_name,'FontWeight','bold','FontSize',16);
                xlabel('Time (days)','FontWeight','bold','FontSize',16);
                if (isempty(Parents(parcell).split)==0 & ((isempty(Parents(Parents(parcell).children(1)).leave) | (Parents(Parents(parcell).children(1)).leave>144)~=0) | (isempty(Parents(Parents(parcell).children(2)).leave) | (Parents(Parents(parcell).children(2)).leave>144)~=0))) | length(Data(parcell).time)>=144
                    place=place+1;
                    % If all to plotted on the same plot; can't get to work
                    % yet. From Matt's code:
%                     figure(2)
%                     subplot(floor(k/15)+1,rem((k+14),15)+1)
%                     while sum(place==dontplace)==1
%                         place=place+1;
%                     end
%                     h=subplot(11,15,place);
%                     set(h,'XTick',[],'YTick',[]);
                    hold on
                    
                    %children of the starting cell:
                    children=horzcat(parcell,Parents(parcell).lineage);
                    
                    locations=1:length(children);
                    Cl(1)=1;
                    marker=1;
                    for jj=2:length(children)
                        %y location of cells
                        Cl(jj)=Cl(children==Parents(children(jj)).parent)+Data(children(jj)).gen/Data(children(jj)).gen^3.4*marker;
                        marker=marker*-1;
                    end
                    for i=1:length(children)
                        
                           lineslope(1).a=0;
                           lineslope(2).a=Data(children(i)).totaldist./30000;
                           lineslope(3).a=(1-Data(children(i)).formfactor)./30;
                           lineslope(4).a=Data(children(i)).eccentricity./30;
                           lineslope(5).a=Data(children(i)).distcentroid./30000;
                          
                           plot(Data(children(i)).time/timepointfix,zeros(1,length(Data(children(i)).time))+Cl(i),'Color',[.4 .4 .4],'LineWidth',1) 
                           patch([Data(children(i)).time/timepointfix fliplr(Data(children(i)).time/timepointfix)],[Data(children(i)).area./5e5+Cl(i)+lineslope(j).a fliplr(-Data(children(i)).area./5e5+Cl(i)+lineslope(j).a)],splitC2{Data(children(i)).gen},'EdgeColor','k');
                           
                         
                            
                            plot(Data(children(i)).time/timepointfix,zeros(1,length(Data(children(i)).time))+Cl(i)+lineslope(j).a,'Color',splitC{Data(children(i)).gen},'LineWidth',1) 
                           if Parents(children(i)).descend>0
                            plot([Data(children(i)).time(end)/timepointfix Data(children(i)).time(end)/timepointfix],[Cl(i)+(Data(children(i)).gen+1)/(Data(children(i)).gen+1)^3.4 Cl(i)-(Data(children(i)).gen+1)/(Data(children(i)).gen+1)^3.4],'k','LineWidth',3)
                           end
                      
                      %%%%%%% DR added to plot cell numbers on trees:
                          
                               this_cell_number = num2str(children(i));
                               number_x_location = median(Data(children(i)).time(1)/timepointfix);
                            
                              if isempty(find(colony_mat == str2num(this_cell_number))) == 1
                                  text(number_x_location,Cl(i),this_cell_number,'FontSize',14)
                              else 
                                  text(number_x_location,Cl(i),this_cell_number,'FontSize',20,'Color','red')
                              end
                           
                              
                               
% 
%                                    if isequal(colony_number, async_table(async_count,5))
%                                        if (isequal(this_cell_number, num2str(async_table(async_count,1))) || isequal(this_cell_number, num2str(async_table(async_count,2))))
%                                   
%                                         text(number_x_location,Cl(i),this_cell_number,'FontSize',18,'Color','red')
%                                         async_count = size(async_table,1)+1;
%                                        else text(number_x_location,Cl(i),this_cell_number,'FontSize',14)
%                                        end
%                                        
%                                    
%                                    end 
                               
                               %%%%%%%%
                         
                      end
                    axis([0 4 .65 1.35])
                    
%                   view(90,90) %rotates trees 90 degrees
                    
                    %%% label the figures to indicate what the slopes mean:
%                     if j==2
%                     ylabel({'slope indicates'; 'total distance traveled'},'FontWeight','bold','FontSize',16);
%                     end
%                     
                    %%%save the figures:
                    if savefigures==1
                      cd(path_to_save);
                       set(gcf,'PaperPositionMode','auto')
                       print(gcf,['labeled_tree_' num2str(k) '_' char(colony_name)],'-dpng', '-r0');
                       
                    end
                end
            end   
        end
end
close all
clear all
cd 'C:\';
Files = dir('*.mat');

end