%% D12: construction of the all_array
% based on D10, which was written by Matt Whitfield
% modified by Deena Rennerfeldt for downstream data analyses

% Makes all_array (with a value for each cell at each time point; if a cell
% doesn't exist at a time point, the value is 0).  Requires getdata6.

% distance and area are in pixels; time is in time points

% after adding all of the outputs from handles.measurements.relabeledcells,
% the all_array additionally has the following properties added to it (in
% order, starting with the first available column):
%       generation
%       distance from colony centroid


%%%%%%%%%%%%%%%%%%%%%%%%
% "Flag" each variable (by setting it's value equal to 1 instaed of 0)
% corresponding to the analyses to be made (see comments for each
% variable).

dotouch=1;          % Flag if cell-cell contacts have been measured in 
                    % CellProfiler (via the MeasureObjectNeighbors module).
                    
grid=1;             % Number of grids being analyzed at a time (just one 
                    % for Project 4).

dopre=0;            % Flag if analyzing the previous presence of cells. 
                    % This requires the ConvertObjectsToImage module as
                    % well as saving the masked images as mat files.
                    
docurr=0;           % Unsure what this does.  
                    % Matt's comment: 1 if detailed current contact runclosea
                    
timepointfix=96;    % conversion factor from # of time points to days.  If 
                    % time points are 15 minutes apart, set this to 96 
                    % (i.e., there are 96 15-minute time points in a day)
                    
threshsml=8000;     % Spread area threshold for considering a cell small

lifetimecutoff=1.5;  % Lifetime of a cell to be considered senescent (for 
                    % twin analysis).

% mintimepoint=50;     % the minimum number of time points a cell has to exi
%                     % to be considered in the twin analyses

% Call function to extract data from input CellProfiler outputs
[parentgrid,labelgrid,areagrid,xlocgrid,ylocgrid,numcells,neighbors,...
    eccentricity,integrateddistance,formfactor]=getdata6(handles,dotouch,...
    grid);
objectgrid=handles.Measurements.RelabeledCells.Number_Object_Number;

% The outputs generated by this function (getdata)are arrays.  See getdata
% for information on how those data are arranged by CellProfiler.  The 
% array outputs are each described below:

% parentgrid:   A "parent object" is the object in the preceeding image that
%              overlaps with the current object (i.e. it's the object/cell 
%              in the previous time point).  A "parent object number" is
%              the label assigned to the parent object.  parentgrid is an
%              array of the parent object numbers for each object at each 
%              time point
%             
% labelgrid:   An array of label numbers for each object at each time point             
%
% areagrid:    An array of the area of each object (in px) at each time
%              point
% xlocgrid, ylocgrid:   x- and y-coordinates of the center of each object
%                       at each time point
% 
% numcells:    the number of cells at each time point
% 
% neighbors:   neighbors is an array constructed in getdata6.m.  The array
%              has two columns: t and n.  t measures percent touching; n
%              measures number of neighbors (for each object at each time 
%              time point).  It is set up to calculate these two variables
%              for a threshold distance of 5, 10, 15, and 20 pixels.  
%              Example: neighbors(3).n is an array containing the number of
%              neighbors each object has at each time point when a distance
%              of 15 pixels was considered for an object to be a neighbor.

%the raw CellProfiler array:
cell_properties = handles.Measurements.RelabeledCells; 
%all of the properties in cell_properties:
property_names = fieldnames(handles.Measurements.RelabeledCells); 
% # of time points:
timepts=length(parentgrid);         
% # of starting cells:
initial_cells = cell2mat(handles.Measurements...
    .Image.Count_RelabeledCells(1));
% # of cells at final time point:
final_cells = cell2mat(handles.Measurements.Image...
    .Count_RelabeledCells(timepts));
% total number of cells to ever exist in this colony:
total_cells = (final_cells - initial_cells)*2 + initial_cells;


%%% If you want to calculate cells' interaction with the previous presence 
%%% of cells at each location:
        % if dopre==1
        %     totalcontact(1:timepts)= struct('a',[]);
        %     totalpxls(1:timepts)=  struct('a',[]);
        %     path3='L:\Subproject_4-2\Complete_colonies\T45C70_Laughing_Shadow\tracked_FINAL\IDs';
        %     [totalcontact,totalpxls]=calcprevcontact(path3,2,RealN,totalcontact,totalpxls);
        % end

%%% Scale the inputs:
        % for i=1:timepts
        %     areagrid{i}=double(areagrid{i});
        %     for j=1:length(areagrid{i})
        %         if areagrid{i}(j)~=-1
        %             areagrid{i}(j)=areagrid{i}(j)*umperpx^2;
        %             xlocgrid{i}(j)=xlocgrid{i}(j)*umperpx;
        %             ylocgrid{i}(j)=ylocgrid{i}(j)*umperpx;
        %             integrateddistance{i}(j)=integrateddistance{i}(j)*umperpx;
        %         end
        %     end
        % end

cells=length(parentgrid{1,1});      % total number of tracked cells (split cells and new cells)
if length(parentgrid{1,1})>1000
    cells2=sum(parentgrid{1,1}(1:1000)~=-1);
    cells1=sum(parentgrid{1,1}(1001:end)~=-1)+1000;
    startcells1=cells1;
else
    cells2=cells;
    cells1=0;
    startcells1=0;
end
startcells2=cells2;
startercells=labelgrid{1,1}(find(labelgrid{1,1}~=-1)); % # of cells at start of experiment 


% Initialize data storage structures
Parents(1:cells)= struct('ancestor',[],'parent',[],'leave',[],'split',[],'children',[],'twin',[],'lineage',[],'lineagetime',[],'born',[],'appear',[],'gen',1,'lifetime',0,'descend',-1,'splitsize',0);
for o=1:length(labelgrid{1,1})
    Parents(o).ancestor=labelgrid{1,1}(o);        % parent # of cells at start
end
Data(1:cells)= struct('num',[],'label',[],'gen',[],'time',[],'area',[],'small',0,'xloc',[],'yloc',[],'prec',[],'pren',[],'eccentricity',[],'formfactor',[],'migrate',[],'totaldist',[]);

RealN(1:timepts)=struct('object_num',[],'num',[],'label',[],'parent',0,'gen',0,'area',0,'xloc',[],'yloc',[],'prec',[],'pren',[],'eccentricity',[],'formfactor',[],'totaldist',[],'distcentroid',[],'distbirth',[]);

RealN(1).num=(1:cells)*0;
RealN(1).label=(1:cells)*0;
RealN(1).parent=(1:cells)*0;
RealN(1).gen=(1:cells)*0;
RealN(1).area=(1:cells)*0;
RealN(1).xloc=(1:cells)*0;
RealN(1).yloc=(1:cells)*0;
RealN(1).eccentricity=(1:cells)*0;
RealN(1).formfactor=(1:cells)*0;
RealN(1).totaldist=(1:cells)*0;
RealN(1).distcentroid=(1:cells)*0;
RealN(1).object_num=(1:cells)*0;
RealN(1).distbirth=(1:cells)*0;

if dopre==1
    RealN(1).prec=(1:cells)*0;
    RealN(1).pren=(1:cells)*0;
end
if dotouch==1
    for np=3
        RealN(1).touch(np).t=(1:cells)*0;
        RealN(1).touch(np).n=(1:cells)*0;
    end
end

%% make the all_array - every property for every cell AT EVERY TIME POINT
% start by making every cell's property = 0
for t = 1:timepts
    for property_counter = 1:length(property_names)
    all_array(t).(property_names{property_counter}) = (1:total_cells)*0;
    end    
end

%% Convert the raw input data into synthesized metrics
property_placeholder = zeros(1,length(property_names));
for t=1:timepts % total number of timesteps
    for c=1:length(parentgrid{1,t})         % number of cells at that timestep
        if parentgrid{1,t}(c)~=-1
            cellN=labelgrid{1,t}(c);        % Cell number (split cells keep parent #)
            parentN=parentgrid{1,t}(c);     % # of cell in previous timestep 
            cellA=areagrid{1,t}(c);         % Cell area
            xloc=xlocgrid{1,t}(c);          % X position of center of mass
            yloc=ylocgrid{1,t}(c);          % Y position of center of mass
            eccen=eccentricity{1,t}(c);
            formfact=formfactor{1,t}(c);
            totaldist=integrateddistance{1,t}(c);
            object_num=objectgrid{1,t}(c);  % Object number of cells
            for property_counter = 1:length(property_names)
                property_placeholder(property_counter) = cell_properties.(property_names{property_counter}){1,t}(c); % a table with all of the properties of THIS cell at THIS time point
            end
       %%%%%no idea why this is here%%%%%      
            if c<1000
                cells=cells2;
            else
                cells=cells1;
            end
       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
       
            if dotouch==1
                for np=1:4
                    touching(np).a=neighbors(np).t{1,t}(c);
                    touchingnum(np).a=neighbors(np).n{1,t}(c);
                end
            end
            cellI=c;
            indexC=find(labelgrid{1,t}==cellN);      % twin cells
            indexP=find(parentgrid{1,t}==parentN);   % if two then split this time

            % uniqueN - unique number assigned to daughter cells when cells split
            if t~=1
                uniqueN=RealN(t-1).num(find(RealN(t-1).label==cellN & RealN(t-1).parent==parentN));
                gen=RealN(t-1).gen(find(RealN(t-1).label==cellN & RealN(t-1).parent==parentN));
            else
                uniqueN=cellN;
                gen=1;
            end

            if length(indexP)>1 && t~=1 && (parentN~=0) % if split this timestep
                cells=cells+1;
                Parents(uniqueN).split=t;               % time that cell split
                Parents(uniqueN).children=horzcat(Parents(uniqueN).children,cells);     % Unique id# of child cells 
                Parents(cells).parent=uniqueN;     % Unique id# of child cells 
                if cellN<=startcells2 || (cellN>1000 && cellN<=startcells1)
                    Parents(cellN).lineage=horzcat(Parents(cellN).lineage,cells);       % Unique id# of all cells that parent cell at start of experiment gives rise to
                    Parents(cellN).lineagetime=horzcat(Parents(cellN).lineagetime,t);       % Time of splits
                end
                uniqueN=cells;                          % Assigns unique number to child cell
                Parents(uniqueN).born=t;                % time daughter cell is "born"
                gen=gen+1; 
                Parents(uniqueN).gen=gen;               % generation of daughter cell
                Parents(uniqueN).ancestor=cellN;          % original parent #
            elseif (parentN==0) && t~=1                   % when a new cell appears (not from division)
                cells=cells+1;
                uniqueN=cells;
                gen=1;
                Parents(uniqueN).gen=gen;               % generation of daughter cell
                %Parents(uniqueN).ancestor=cellN;          % original parent #
                Parents(uniqueN).appear=t;
            end
            if dopre==1
                prec=totalcontact(1,t).a(uniqueN);      % total number of previous cell contact under cell
                pren=totalpxls(1,t).a(uniqueN);         % number of pixels under cell
            end
            RealN(t).num(uniqueN)=uniqueN;
            RealN(t).label(uniqueN)=cellN;
            RealN(t).parent(uniqueN)=cellI;  
            RealN(t).gen(uniqueN)=gen; 
            RealN(t).area(uniqueN)=cellA;
            RealN(t).xloc(uniqueN)=xloc;
            RealN(t).yloc(uniqueN)=yloc;
            RealN(t).eccentricity(uniqueN)=eccen;
            RealN(t).formfactor(uniqueN)=formfact;
            RealN(t).totaldist(uniqueN)=totaldist;
            RealN(t).object_num(uniqueN)=object_num;
             
            for property_counter = 1:length(property_names)
            all_array(t).(property_names{property_counter})(uniqueN)...
                = property_placeholder(property_counter);
            end
           
            if dopre==1
                RealN(t).prec(uniqueN)=prec;
                RealN(t).pren(uniqueN)=pren;
            end
            if dotouch==1
                for np=1:4
                    RealN(t).touch(np).t(uniqueN)=touching(np).a;
                    RealN(t).touch(np).n(uniqueN)=touchingnum(np).a;
                end
            end
            if c<1000
                cells2=cells;
            else
                cells1=cells;
            end
        end
    end
end
%%%%% Find the centroid of a colony at each time point
clear i
centroid = zeros(timepts,2);
for i = 1:timepts
    %cell coordinates:
    XValues=(handles.Measurements.RelabeledCells.AreaShape_Center_X{1,i});
    YValues=(handles.Measurements.RelabeledCells.AreaShape_Center_Y{1,i});
    
    if length(XValues) == 1 %if there is only one cell
        XCoord = XValues;
        YCoord = YValues;
    else
        XCoord=mean(XValues);
        YCoord=mean(YValues);
    end
    centroid(i,1) = XCoord; 
    centroid(i,2) = YCoord;
end
%%%%% Put the distance from centroid for each cell into RealN:

for i = 1:timepts %for each time point
    for j = 1:length(RealN(i).num) %for each cell at a time point
        if RealN(i).num(j)~=0
        RealN(i).distcentroid(j) = sqrt((RealN(i).xloc(j) - centroid(i,1))^2 + (RealN(i).yloc(j) - centroid(i,2))^2);
        else
        RealN(i).distcentroid(j)=0;
        end
    end 
end


% Determine lineage of cells that split after start of experiment
for c=startcells2+1:cells
    if c<=cells2 || c>startcells1
        child1=c;
        child2=c;
        i=1;
        while isempty(Parents(child1).children)==0
            child2=Parents(child1).children(2);
            child1=Parents(child1).children(1);
            Parents(c).lineage=horzcat(Parents(c).lineage,child1,child2);
    %         Parents(c).lineagetime=horzcat(Parents(c).lineagetime,t,t);
            while isempty(Parents(child2).children)==0
                child1=Parents(child2).children(1);
                child2=Parents(child2).children(2);
                Parents(c).lineage=horzcat(Parents(c).lineage,child1,child2);
            end
        end
    end
end

% Determine twins from cells existing in first image
for i=1:startcells2
    for ii=1:2:length(Parents(i).lineage)
        Parents(Parents(i).lineage(ii)).twin=Parents(i).lineage(ii+1);
        Parents(Parents(i).lineage(ii+1)).twin=Parents(i).lineage(ii);
    end
end

% Determine twins from cells existing in first image
if c>1000
    for i=1001:startcells1
        for ii=1:2:length(Parents(i).lineage)
            Parents(Parents(i).lineage(ii)).twin=Parents(i).lineage(ii+1);
            Parents(Parents(i).lineage(ii+1)).twin=Parents(i).lineage(ii);
        end
    end
end

for i=1:cells
    if c<=cells2 || c>startcells1
        % These only produce output for cells that have split and been born
        Parents(i).lifetime=Parents(i).split-Parents(i).born;
        if isempty(Parents(i).lifetime)==1
            Parents(i).lifetime=0;
        end
        Parents(i).descend=length(Parents(i).lineage);

        % Find out avg cell size 8-4 timepoints before split
        if Parents(i).split>0 %if the time point the cell divides exists
            if isempty(Parents(i).appear)==0 % 
                if (Parents(i).split-Parents(i).appear)>8 
                    %there is an error in the line below... attempting to
                    %edit it (DR 10/24/16)
                  %  Parents(i).splitsize=mean([RealN(Parents(i).split-4).area(i),RealN(Parents(i).split-5).area(i),RealN(Parents(i).split-6).area(i),RealN(Parents(i).split-7).area(i),RealN(Parents(i).split-8).area(i)]);
                    Parents(i).splitsize=mean([RealN(Parents(i).split-4).area(i),RealN(Parents(i).split-5).area(i),RealN(Parents(i).split-6).area(i),RealN(Parents(i).split-7).area(i),RealN(Parents(i).split-8).area(i)]);

                end
            else
                if (Parents(i).split-Parents(i).born)>8
                    Parents(i).splitsize=mean([RealN(Parents(i).split-4).area(i),RealN(Parents(i).split-5).area(i),RealN(Parents(i).split-6).area(i),RealN(Parents(i).split-7).area(i),RealN(Parents(i).split-8).area(i)]);
                end
            end
        end
        if isempty(Parents(i).splitsize)==1
            Parents(i).splitsize=0;
        end

        % To convert data to matrix form for plotting
        counter=0;
        for j=1:timepts
            if i<=RealN(j).num(end)
                if RealN(j).num(i)~=0
                    counter=counter+1;
                    Data(i).num=RealN(j).num(i);
                    Data(i).label=RealN(j).label(i);
                    Data(i).gen=RealN(j).gen(i);
                    Data(i).time(counter)=j;
                    Data(i).area(counter)=RealN(j).area(i);
                    Data(i).xloc(counter)=RealN(j).xloc(i);
                    Data(i).yloc(counter)=RealN(j).yloc(i);
                    Data(i).eccentricity(counter)=RealN(j).eccentricity(i);
                    Data(i).formfactor(counter)=RealN(j).formfactor(i);
                    Data(i).totaldist(counter)=RealN(j).totaldist(i);
                    Data(i).distcentroid(counter)=RealN(j).distcentroid(i);
                    if counter>1
                        Data(i).migrate(counter)=sqrt((Data(i).xloc(counter)-Data(i).xloc(counter-1))^2+(Data(i).yloc(counter)-Data(i).yloc(counter-1))^2)*2;
                    else
                        Data(i).migrate(counter)=0;
                    end
                    if dopre==1
                        Data(i).prec(counter)=RealN(j).prec(i);
                        Data(i).pren(counter)=RealN(j).pren(i);
                    end
                    if dotouch==1
                        for np=1:4
                            Data(i).touch(np).t(counter)=RealN(j).touch(np).t(i);
                            Data(i).touch(np).n(counter)=RealN(j).touch(np).n(i);
                        end
                    end
                end
            end
        end
    end
    Data(i).totaldist= Data(i).totaldist-Data(i).totaldist(1);
end
%%%%% find the distance from the location at birth for each cell at each
%%%%% time point:
    clear cellcount 
    birthmat = zeros(size(RealN(end).num,2),2);
    %find the birth location:
    for cellcount = 1:length(RealN(end).num) % for each cell
        birthtime = Data(cellcount).time(1); %time point of birth
        birthmat(cellcount,1) = RealN(birthtime).xloc(cellcount);
        birthmat(cellcount,2) = RealN(birthtime).yloc(cellcount);
    end
    %incorporate distance from birth at every time point into RealN
    clear cellcount timecount
    for timecount = 1:timepts %for each time point
        for cellcount = 1:length(RealN(timecount).num) %for each cell at a time point
            if RealN(timecount).num(cellcount)~=0 %if the cell exists here    
            RealN(timecount).distbirth(cellcount) = sqrt((RealN(timecount).xloc(cellcount) - birthmat(cellcount,1))^2 + (RealN(timecount).yloc(cellcount) - birthmat(cellcount,2))^2);
            else
            RealN(i).distbirth(j)=0;
            end
        end 
    end
    

% find cells that disappear but dont divide
for i=1:length(RealN(timepts).num)
    if isempty(Data(i).time)==0
        if isempty(Parents(i).split)==1 && Data(i).time(end)~=timepts
            Parents(i).leave=Data(i).time(end)+1;
        end
    end
end

numcell=(1:timepts)*0;
areacell=(1:timepts)*0;
areacellsem=(1:timepts)*0;
smallcell=zeros(length(threshsml),timepts);
largecell=zeros(length(threshsml),timepts);
for o=1:timepts
    numcell(o)=numcells(o);         % total # of cells over time
    areacell(o)=mean(RealN(o).area(RealN(o).area~=0));
    areacellsem(o)=std(RealN(o).area(RealN(o).area~=0))/sqrt(length(RealN(o).area(RealN(o).area~=0)));
    for p=1:length(threshsml)
        smallcell(p,o)=sum(areagrid{o}<=threshsml(p) & areagrid{o}>0);
        largecell(p,o)=sum(areagrid{o}>threshsml(p));
    end
end


genlist=[];
lifetime=[];
dividesize=[];
% descend=[];
descend(1:cells)=(1:cells)*0-1;
genname=[];
for i=1:cells
    if Parents(i).lifetime>0 && (Parents(i).ancestor<=startcells2 )%|| (Parents(i).ancestor<=startcells1 &&  Parents(i).ancestor>1000))
        lifetime=vertcat(lifetime,Parents(i).lifetime);
        dividesize=vertcat(dividesize,Parents(i).splitsize);
        genlist=vertcat(genlist,Parents(i).gen);
        genname=vertcat(genname,Data(i).num);
%         descend=vertcat(descend,Parents(i).descend);
    end
    descend(i)=Parents(i).descend;
end

% Statistics within each generation of cells
genN(1:timepts)=struct('A',[],'N',[],'Std',[],'CSb',[],'CSl',[]);
for o=1:max(genlist)+1
    CSb=0;
    CSl=0;
    for i=1:timepts
        genN(o).A(i)=mean(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        genN(o).N(i)=length(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        genN(o).Std(i)=std(RealN(i).area(RealN(i).gen==o & (RealN(i).label<startcells2+1 | (RealN(i).label<startcells1+1 & RealN(i).label>1000))));
        for j=1:length(Parents)
            if Parents(j).born==i 
                if Parents(j).gen==o & (Parents(j).ancestor<=startcells2 | (Parents(j).ancestor<=startcells1 &  Parents(j).ancestor>1000))
                    CSb=CSb+1;
                end
            end
            if Parents(j).leave==i 
                if Parents(j).gen==o & ((Parents(j).ancestor<=startcells2 & Parents(j).ancestor>0) | (Parents(j).ancestor<=startcells1 &  Parents(j).ancestor>1000))
                   CSl=CSl+1;
                end
            end
        end 
        genN(o).CSb(i)=CSb;
        genN(o).CSl(i)=CSl;
    end
end

% Cumulative sum
cumm(1:max(genlist))=struct('a',[],'b',[],'c',[],'d',[]);
for j=2:max(genlist)+1
    for i=1:length(Parents)
        if Parents(i).gen==j && (Parents(i).ancestor<=startcells2 || (Parents(i).ancestor<=startcells1 &&  Parents(i).ancestor>1000))
            cumm(j-1).a=horzcat(cumm(j-1).a,Parents(i).born);
            if isempty(Parents(i).leave)~=1
                cumm(j-1).c=horzcat(cumm(j-1).c,Parents(i).leave);
            end
        end
    end
    cumm(j-1).a=sort(cumm(j-1).a);
    cumm(j-1).b=horzcat(0,1:length(cumm(j-1).a),length(cumm(j-1).a));
    cumm(j-1).a=horzcat(0,cumm(j-1).a,timepts)/timepointfix;
    
    cumm(j-1).c=sort(cumm(j-1).c);
    cumm(j-1).d=horzcat(0,1:length(cumm(j-1).c),length(cumm(j-1).c));
    cumm(j-1).c=horzcat(0,cumm(j-1).c,timepts)/timepointfix;
end

%add more properties that are in RealN:
for t = 1:timepts
    all_array(t).generation = (1:total_cells)*0;
    all_array(t).dist_from_centroid = (1:total_cells)*0;
    all_array(t).dist_from_birth = (1:total_cells)*0;
%   all_array(t).senescence = (1:total_cells)*0;
end 

% for each time point:
for t = 1:timepts
    %for each cell at that time point:
    for cell_counter = 1:length(RealN(t).gen) 
        %generation for each cell:
        all_array(t).generation(cell_counter) = RealN(t).gen(cell_counter);
        %distance each cell is from centroid:
        all_array(t).dist_from_centroid(cell_counter) = ...
            RealN(t).distcentroid(cell_counter);
        %distance cell is from birth location:
        all_array(t).dist_from_birth(cell_counter) = ...
            RealN(t).distbirth(cell_counter);
    end
%     if t==timepts
        
end

property_names = fieldnames(all_array);

%%% Fix Parents.lineage and Parents.descend:
        % number of cells at first time point:
        initialcells = length(RealN(1).num);
        % set up a new column in Parents to have the lineage each cell:
        Parents(1).lineage_all = [];
        
        % go through each cell, starting with the final one and working
        % backward to the starting cells
        for kidcount = size(Parents,2):-1:(initialcells + 1)
           this_parent = Parents(kidcount).parent;
           Parents(this_parent).lineage_all(end+1) = kidcount;
            %do nothing else if this cell doesn't have children:
           if isempty(Parents(kidcount).children) 
           % if this cell DOES have children, add this cell's lineage to
           % its parent's
           else 
            Parents(this_parent).lineage_all = ...
                horzcat(Parents(kidcount).lineage_all,...
                Parents(this_parent).lineage_all);         
           end
        end
    %%%